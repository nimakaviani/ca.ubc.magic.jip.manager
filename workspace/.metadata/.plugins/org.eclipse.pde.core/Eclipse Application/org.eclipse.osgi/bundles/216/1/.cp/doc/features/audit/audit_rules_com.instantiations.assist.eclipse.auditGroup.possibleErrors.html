<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Possible Errors</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Possible Errors</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for places where the code might contain errors.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.accidentalConcatenation">Accidental Concatenation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.arrayIsStoredWithoutCopying">Array Is Stored Without Copying</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.assignmentInCondition">Assignment In Condition</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.assignmentToNonFinalStatic">Assignment to Non-final Static</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.avoidComparingClassesByStrings">Avoid Comparing Classes By String Names</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidFutureKeywords">Avoid Future Keywords</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.returnValue">Avoid null Return Values</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.bewareOfURLEqualsAndHashCode">Beware of URL equals() and hashCode()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.checkTypeInEquals">Check Type In Equals</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.closeInFinally">Close In Finally</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.closeWhereCreated">Close Where Created</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.comparisonOfConstants">Comparison Of Constants</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.comparisonOfShortAndChar">Comparison Of Short And Char</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.constantConditionalExpression">Constant Conditional Expression</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.constructorsOnlyInvokeFinalMethods">Constructors Only Invoke Final Methods</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.danglingElse">Dangling Else</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyCatchClause">Empty Catch Clause</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.emptyClass">Empty Class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyDoStatement">Empty Do Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyEnhancedForStatement">Empty Enhanced For Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyFinalizeMethod">Empty Finalize Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyFinallyClause">Empty Finally Clause</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyForStatement">Empty For Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyIfStatement">Empty If Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyInitializer">Empty Initializer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyMethod">Empty Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyStatement">Empty Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptySwitchStatement">Empty Switch Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptySynchronizedStatement">Empty Synchronized Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyTryStatement">Empty Try Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyWhileStatement">Empty While Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.entryPointMethod">Entry Point Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.expressionValue">Expression Evaluation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.fieldMayHaveNullValue">Field Might Have Null Value</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.floatingPointUse">Floating Point Use</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.handleNumericParsingErrors">Handle Numeric Parsing Errors</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.improperCalculationOfArrayHashCode">Improper calculation of array hashCode</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.improperConversionOfArrayToString">Improper conversion of Array to String</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.incompatibleTypesStoredInACollection">Incompatible types stored in a collection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.inconsistentUseOfOverride">Inconsistent Use of Override</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.integerDivisionInFloatingPointExpression">Integer Division in a Floating-point Expression</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.invalidLoopConstruction">Invalid Loop Construction</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.lossOfPrecisionInCast">Loss of Precision in Cast</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingConstantsInSwitch">Missing Constants In Switch</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingDefaultInSwitch">Missing Default in Switch</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingStaticMethod">Missing static method in non-instantiable class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingUpdateInFor">Missing Update in For Statement</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.misspelledMethodName">Misspelled Method Name</a></li>
      <li><a href="#com.instantiations.assist.eclipse.callNextWithoutHasNext">Next method invoked without hasNext method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nonCaseLabelInSwitch">Non-case Label in Switch</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nonTerminatedCaseClause">Non-terminated Case Clause</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.overloadedEquals">Overloaded Equals</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.overloadedMethods">Overloaded Methods</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.possibleNullPointer">Possible Null Pointer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.potentialInfiniteLoop">Potential Infinite Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.recursiveCallWithNoCheck">Recursive Call With No Check</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.repeatedAssignment">Repeated Assignment</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.returnInFinally">Return in Finally</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.stringIndexOfUse">String indexOf Use</a></li>
      <li><a href="#com.instantiations.assist.eclipse.subClassShouldOverrideMethod">Subclass should override method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.throwInFinally">Throw in Finally</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.unassignedField">Unassigned Field</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryInstanceof">Unnecessary "instanceof" Test</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryNullCheck">Unnecessary Null Check</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryReturn">Unnecessary Return</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.unusedReturnValue">Unused Return Value</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unusedStringBuffer">Unused StringBuffer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unusedStringBuilder">Unused StringBuilder</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.usageOfBinaryComparison">Usage Of Binary Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useIdentityToCompareNull">Use == to Compare With null</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.variableShouldNotHaveNullValue">Variable Has Null Value</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.variableUsage">Variable Usage</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.accidentalConcatenation">Accidental Concatenation</a></h4><p>
<b>Summary</b><br/>Two numbers concatenated without any characters in between is probably an error.<p><b>Description</b><br/>This audit rule finds places where two or more numbers are being concatenated without intervening strings or characters. This is usually a mistake caused by forgetting to parenthesize the sub-expression.<p><b>Example</b><br/>The addition of the two integers in the code below would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public String getSummary(int passCount, int failCount) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Of the " + passCount + failCount + " students, "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ passCount + " passed and " + failCount + " failed.";<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.arrayIsStoredWithoutCopying">Array Is Stored Without Copying</a></h4><p>
<b>Summary</b><br>Storing of arrays without copying should not be used.<p><b>Description</b><br>This audit rule looks for places where arrays are stored without copying.<p><b>Security Implications</b><br>If constructors and methods receive and store arrays without copying, these arrays could be unpredictably changed from outside of the class.<p><b>Example</b><p>The following declaration of the <code>setArray</code> method will be marked as a violation because it does not copy its parameter:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private String[] array;<br/>&nbsp;&nbsp;&nbsp;&nbsp;....<br/>&nbsp;&nbsp;&nbsp;&nbsp;public void setArray( String[] newArray){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.array = newArray;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.assignmentInCondition">Assignment In Condition</a></h4><p>
<b>Summary</b><br/>The assignment operator should never be used in a condition.<p><b>Description</b><br/>This audit rule finds places in the code where an assignment operator is used within a condition associated with an if, for, while or do statement. Such uses are often caused by mistyping a single equal (=) where a double equal (==) was intended.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (a = 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.assignmentToNonFinalStatic">Assignment to Non-final Static</a></h4><p>
<b>Summary</b><br/>Static fields should only be changed in static methods.<p><b>Description</b><br/>Assignments to a static field in a non-static context are usually not intended, and therefore usually represent an error.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static int x = 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public doSomething(int y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_assignment_to_non_final_static.gif"></p><h4><a name="com.instantiations.assist.eclipse.analysis.avoidComparingClassesByStrings">Avoid Comparing Classes By String Names</a></h4><p>
<b>Summary</b><br/>String comparisons should not occur with the output from Class.getName()<p><b>Description</b><br/>This audit rule looks for places where a class name is compared using the methods String.equals or String.equalsIgnoreCase, or the == or != operators.<p>Specifically, this audit rule flags the following patterns:<p><code>[class].getName().equals(*)<br>*.equals([class].getName())<br>[class].getName().equalsIgnoreCase(*)<br>*.equalsIgnoreCase([class].getName())<br>[class].getName() == *<br>* == [class].getName()<br>[class].getName() != *<br>* != [class].getName()</code><p>Where [class] is any instance of <code>java.lang.Class</code>.<p><b>Security Implications</b><br/>By not making comparisons in this way, code is prevented from malicious users creating a class with the same name in order to gain access to blocks of code not intended by the programmer.<p><b>Example</b><br/>The following method invocation of equals would be flagged a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if ("SomeClassName".equals(class.getName())) ...</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidFutureKeywords">Avoid Future Keywords</a></h4><p>
<b>Summary</b><br/>Avoid using names that conflict with future keywords.<p><b>Description</b><br/>Words that will be keywords in later versions of Java should not be used as an identifier. Otherwise, you will have to rewrite the code in order to migrate.<p><b>Example</b><br/>Any variable, method, or type named "assert" or "enum" will be flagged.<h4><a name="com.instantiations.assist.eclipse.audit.returnValue">Avoid null Return Values</a></h4><p>
<b>Summary</b><br/>Return values should not be null.<p><b>Description</b><br/>This audit rule finds places where null is returned rather than array types or simple types.<p><b>Example</b><br/>The return statement in the following method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int[] getRowSums()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (table == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.bewareOfURLEqualsAndHashCode">Beware of URL equals() and hashCode()</a></h4><p>
<b>Summary</b><br/>Be careful when and how you use the <code>equals()</code> and <code>hashCode()</code> methods of the <code>URL</code> class.<p><b>Description</b><br/>Both the <code>equals()</code> and <code>hashCode()</code> methods of the <code>URL</code> class resolve the domain name using the Internet. This operation can cause unexpected performance problems. Also, the <code>hashCode()</code> method takes the resolved IP address into account when generating the hash code. This can cause serious problems since many web sites use dynamic DNS. It is possible to store a <code>URL</code> in a hashed collection, and later be unable to retrieve it if the <code>URL</code> resolves to a different IP address.<p>Because of these implementation problems, it is a good idea to convert <code>URL</code>s to <code>URI</code>s before storing them in collections, or using their <code>equals()</code> or <code>hashCode()</code> methods. This can be done easily using <code>URL</code>'s <code>toURI()</code> method, and reversed using <code>URI</code>'s <code>toURL()</code> method.<p>This rule finds places where <code>equals()</code> or <code>hashCode()</code> are explicitly invoked on <code>URL</code> objects and places where URL objects are used in hashed Collections classes. <p><b>Example</b><br/>The following would be flagged as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;URL aUrl = new URL("http://address.com");<br>&nbsp;&nbsp;&nbsp;&nbsp;Set aSet = new HashSet();<br>&nbsp;&nbsp;&nbsp;&nbsp;aSet.add(aUrl);</code><h4><a name="com.instantiations.assist.eclipse.audit.checkTypeInEquals">Check Type In Equals</a></h4><p>
<b>Summary</b><br/>Implementations of equals() should check the type of the parameter.<p><b>Description</b><br/>This audit rule finds implementations of the method equals() that do not check the type of the parameter. The rule can be configured for how the type of the parameter should be checked.<p><b>Example</b><br/>The following declaration of the equals() method would be flagged because the type of the argument is not checked:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object other)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getName().equals(((Employee) other).getName());<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_check_type_equals.gif" width="288" height="63"></p><h4><a name="com.instantiations.assist.eclipse.audit.closeInFinally">Close In Finally</a></h4><p>
<b>Summary</b><br/>The method close() should be invoked inside a finally block.<p><b>Description</b><br/>This rule finds places where the method close() is invoked outside of a finally block.<p><b>Example</b><br/>The following invocation would be flagged as a violation because it occurs outside of a finally block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void readFile(FileReader reader)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.closeWhereCreated">Close Where Created</a></h4><p>
<b>Summary</b><br/>Streams, readers, writers and sockets should be closed in the method where they are created.<p><b>Description</b><br/>Instances of subclasses of java.io.InputStream, java.io.OutputStream, java.io.Reader, java.io.Writer, and java.net.Socket should be closed in the same method in which they are created in order to avoid errors caused when they are not closed at all.<p><b>Example</b><br/>The creation of a reader in the following method would be flagged as a violation because the reader is not closed:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void readFile(String filePath)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileReader reader;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader = new FileReader(new File(filePath));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readFile(reader);<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_close_where_created.gif" width="378" height="197"></p><h4><a name="com.instantiations.assist.eclipse.audit.comparisonOfConstants">Comparison Of Constants</a></h4><p>
<b>Summary</b><br/>Constants should not be directly compared.<p><b>Description</b><br/>Comparisons of two constant values waste processor cycles.<p><b>Example</b><br/>Given the following declarations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;static final int ZERO = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;static final int ONE = 1;<br></code><p>The following condition would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (ZERO != ONE) {</code><h4><a name="com.instantiations.assist.eclipse.audit.comparisonOfShortAndChar">Comparison Of Short And Char</a></h4><p>
<b>Summary</b><br/>Values of type short and char should not be directly compared.<p><b>Description</b><br/>Comparisons between short and char values are performed by widening both to the type int and then performing the comparison. However, because shorts are signed and chars are unsigned, this can produce unintended results.<p><b>Example</b><br/>The following would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;short s;<br>&nbsp;&nbsp;&nbsp;&nbsp;char c;<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s == c) ...</code><h4><a name="com.instantiations.assist.eclipse.audit.constantConditionalExpression">Constant Conditional Expression</a></h4><p>
<b>Summary</b><br/>Conditional expressions should usually not be constant valued.<p><b>Description</b><br/>This audit rule looks for conditional expressions in if, do, for, and while statements whose value is a compile-time constant. Because the value of such conditions cannot change, either the conditional code will never execute or will always execute (and in the case of a loop, the loop will never terminate).<p><b>Example</b><br/>The expression in the following code would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (false) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thisWillNeverBeExecuted();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.constructorsOnlyInvokeFinalMethods">Constructors Only Invoke Final Methods</a></h4><p>
<b>Summary</b><br/>Constructors should only invoke final methods on the object being constructed.<p><b>Description</b><br/>Subclasses can override non-final methods. Invoking them from a constructor can cause errors because the object is not in a valid state.<p><b>Example</b><br/>The constructor in the following class would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Point<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Point()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = initialX();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = initialY();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected int initialX()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.danglingElse">Dangling Else</a></h4><p>
<b>Summary</b><br/>Use blocks to prevent dangling else clauses.<p><b>Description</b><br/>This audit rule finds places in the code where else clauses are not preceded by a block because these can lead to dangling else errors.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (a &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a &gt; 100)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = a - 100;<br>&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = -a;</code><p><img src="../../images/auditrules/audit_dangling_else.gif" width="305" height="22"></p><h4><a name="com.instantiations.assist.eclipse.audit.emptyCatchClause">Empty Catch Clause</a></h4><p>
<b>Summary</b><br/>Catch clauses should not be empty.<p><b>Description</b><br/>This rule finds places where an exception is caught and nothing is done. It can be configured to allow the existence of a comment to substitute for actual Java code.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_empty_catch_clause.gif" width="404" height="30"></p><h4><a name="com.instantiations.assist.eclipse.analysis.emptyClass">Empty Class</a></h4><p>
<b>Summary</b><br/>Empty classes should not be declared.<p><b>Description</b><br/>This audit rule checks for class declarations that do not include any members (fields, methods, or inner classes). Such classes usually occur if either the implementation was not finished or if the class was being used as a marker. In the latter case the class should be replaced by an interface.<p><b>Example</b><br/>The following class definition would be flagged as being a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class EmptyClass<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyDoStatement">Empty Do Statement</a></h4><p>
<b>Summary</b><br/>Do statements should not be empty.<p><b>Description</b><br/>This rule finds do statements whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;do {<br>&nbsp;&nbsp;&nbsp;&nbsp;} while(someCondition());</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyEnhancedForStatement">Empty Enhanced For Statement</a></h4><p>
<b>Summary</b><br/>The body of an enhanced for loop should never be empty.<p><b>Description</b><br/>This audit rule finds enhanced for loops whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int count : counts) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyFinalizeMethod">Empty Finalize Method</a></h4><p>
<b>Summary</b><br/>The body of a finalize method should never be empty.<p><b>Description</b><br/>This audit rule finds finalize methods whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;protected void finalize()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyFinallyClause">Empty Finally Clause</a></h4><p>
<b>Summary</b><br/>Finally clauses should never be empty.<p><b>Description</b><br/>This audit rule finds finally clauses whose block is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyForStatement">Empty For Statement</a></h4><p>
<b>Summary</b><br/>The body of a for loop should never be empty.<p><b>Description</b><br/>This audit rule finds for loops whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyIfStatement">Empty If Statement</a></h4><p>
<b>Summary</b><br/>The clauses of an if statement should never be empty.<p><b>Description</b><br/>This audit rule finds if statements whose then or else clauses are empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (this == that) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyInitializer">Empty Initializer</a></h4><p>
<b>Summary</b><br/>The body of an initializer should never be empty.<p><b>Description</b><br/>This audit rule finds initializers whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;static {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyMethod">Empty Method</a></h4><p>
<b>Summary</b><br/>Empty methods should never be used.<p><b>Description</b><br/>Methods with an empty body usually occur only when someone has forgotten to implement the method. This audit rule finds methods whose body is empty. <p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public void doSomething()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_empty_method.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.emptyStatement">Empty Statement</a></h4><p>
<b>Summary</b><br/>Empty statements should never be used.<p><b>Description</b><br/>This audit rule finds places where an empty statement occurs within a control structure. (An empty statement is a semicolon appearing alone in a place where a statement is allowed). The existence of an empty statement usually indicates a problem, such as a piece of code that was unintentionally removed or a semicolon added in the wrong place.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (hasBeenAuthenticated);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grantSpecialAccess();</code><h4><a name="com.instantiations.assist.eclipse.audit.emptySwitchStatement">Empty Switch Statement</a></h4><p>
<b>Summary</b><br/>The body of a switch statement should never be empty.<p><b>Description</b><br/>This audit rule finds switch statements whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptySynchronizedStatement">Empty Synchronized Statement</a></h4><p>
<b>Summary</b><br/>Synchronized statements should never be empty.<p><b>Description</b><br/>This audit rule finds empty synchronized statements.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;synchronized (monitor) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyTryStatement">Empty Try Statement</a></h4><p>
<b>Summary</b><br/>The body of a try statement should never be empty.<p><b>Description</b><br/>This audit rule finds try statements whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.emptyWhileStatement">Empty While Statement</a></h4><p>
<b>Summary</b><br/>The body of a while statement should never be empty.<p><b>Description</b><br/>This audit rule finds while statements whose body is empty.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;while (index &lt; count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.entryPointMethod">Entry Point Method</a></h4><p>
<b>Summary</b><br/>The main() method should be defined as "public static void main(java.lang.String[])".<p><b>Description</b><br/>This audit rule finds main() methods that are not defined as "public static void main(java.lang.String[])". The main() method should only be used as the entry point for a class.<p><b>Example</b><br/>The following method would be flagged as a violation because it is not declared to be a static method:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void main(String[] args)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.expressionValue">Expression Evaluation</a></h4><p>
<b>Summary</b><br/>Expression evaluation.<p><b>Description</b><br/>This set of audit rules checks the value of expressions for certain conditions. It detects constant and zero values, divide-by-zero, and others.<p><b>Example</b><br/>The following expression would be flagged as a violation because it always produces the same value:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int secondsPerDay = 24 * 60 * 60;</code><p>The following expression would be flagged as a violation because it will always cause a divide by zero exception:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;return 23 / 0;</code><p><img src="../../images/auditrules/audit_expression_evaluation.gif" width="261" height="173"></p><h4><a name="com.instantiations.assist.eclipse.audit.fieldMayHaveNullValue">Field Might Have Null Value</a></h4><p>
<b>Summary</b><br/>You should check fields used in methods beacuse they might have <code>null</code> value.<p><b>Description</b><br/>This audit rule looks for references to fields whose value can be <code>null</code> where the value of the field is not checked before being dereferenced.<p><b>Security Implications</b><br/>Use checks on a null pointer because <code>NullPointerException</code> might be thrown.<p><b>Example</b><br/>The following usage of the field <code>date</code> will be marked as a violation beacuse it is not checked:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class TestClass {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Date date = null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void badUsage() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String myStr = date.toString();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.floatingPointUse">Floating Point Use</a></h4><p>
<b>Summary</b><br/>Floating point values should not be used.<p><b>Description</b><br/>This audit rule checks for uses of floating point values. It finds such uses as the declared type of variables, the return type of methods, literal values, references to floating point valued variables, and the invocation of methods that return floating point values. Floating point values should rarely be used because of the potential for rounding errors.<p><b>Example</b><br/>The following declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private float accountBalance;</code><h4><a name="com.instantiations.assist.eclipse.audit.handleNumericParsingErrors">Handle Numeric Parsing Errors</a></h4><p>
<b>Summary</b><br/>Numeric parsing errors should be handled where they occur.<p><b>Description</b><br/>This audit rule finds invocations of methods that parse numeric values from Strings (and hence can throw a NumberFormatException) where the exception is not handled (caught) in the same scope.<p><b>Example</b><br/>The following invocation of parseInt would be flagged because it is not wrapped in a try statement that catches NumberFormatException:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int value = Integer.parseInt("42");</code><h4><a name="com.instantiations.assist.eclipse.audit.improperCalculationOfArrayHashCode">Improper calculation of array hashCode</a></h4><p>
<b>Summary</b><br/>Because the <code>hashCode()</code> method of an array returns the identityhashCode, this method should not be used to generate hash codes for arrays.<p><b>Description</b><br/>This audit rule looks for invocations of <code>hashCode()</code> on arrays, as well as common functions that will invoke <code>hashCode()</code> on an array. <p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Person[] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Alice"), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Bob"), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Charlie")<br>&nbsp;&nbsp;&nbsp;&nbsp;}.hashCode();</code><h4><a name="com.instantiations.assist.eclipse.audit.improperConversionOfArrayToString">Improper conversion of Array to String</a></h4><p>
<b>Summary</b><br/>Because the <code>toString()</code> method of an array does not generate useful information, some functions that accept object parameters will display useless results when an array is passed to them.<p><b>Description</b><br/>This audit rule looks for invocations of <code>toString()</code> on arrays, as well as common functions that will convert an array to a String using the <code>toString()</code> method. <code>toString()</code> does not return the contents of the array in a useful format, instead, it generates a string similar to <code>[C@16f0472</code>.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(new Person[] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Alice"), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Bob"), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Charlie")<br>&nbsp;&nbsp;&nbsp;&nbsp;});</code><h4><a name="com.instantiations.eclipse.analysis.audit.security.incompatibleTypesStoredInACollection">Incompatible types stored in a collection</a></h4><p>
<b>Summary</b><br/>You should avoid incompatible casts because a <code>ClassCastException</code> will be thrown.<p><b>Description</b><br/>This audit rule looks for places in the code that cast elements retrieved from a collection to a type that is not compatible with the type of elements being put into that very collection.<p><b>Security Implications</b><br/>Incompatible cast will cause a <code>ClassCastException</code> to be thrown. This could be used to create a potential denial-of-service state or reveal security-sensitive parts of an application's design through the stack trace.<p><b>Example</b><br/>The following invocation of the <code>get()</code> method will be marked as a violation because its return value is cast to a type incompatible with the one being put into collection:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private List testList;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod(MyClass obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testList.add(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer test = (Integer)testList.get(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.inconsistentUseOfOverride">Inconsistent Use of Override</a></h4><p>
<b>Summary</b><br/>The Override annotation should be used for all overridden methods.<p><b>Description</b><br/>This audit rule finds classes that use the Override annotation for some overridden methods but not for others and flags those for which it is missing.<h4><a name="com.instantiations.assist.eclipse.audit.integerDivisionInFloatingPointExpression">Integer Division in a Floating-point Expression</a></h4><p>
<b>Summary</b><br/>Integers should be converted to floats before division if the result will be converted.<p><b>Description</b><br/>When integer values are divided, any remainder is truncated. If the result of that division is going to be converted to a floating-point value, one of the integers should probably be cast to that same floating-point type in order to avoid the rounding error.<p><b>Example</b><br/>The following division would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int a, b;<br>&nbsp;&nbsp;&nbsp;&nbsp;float result;<br>&nbsp;&nbsp;&nbsp;&nbsp;result = a / b;</code><h4><a name="com.instantiations.assist.eclipse.audit.invalidLoopConstruction">Invalid Loop Construction</a></h4><p>
<b>Summary</b><br/>Loops should be properly bounded.<p><b>Description</b><br/>This audit rule checks for loops whose initial and/or final values could allow the index to go outside the bounds of the collection being accessed within the body of the loop.<p><b>Example</b><br/>The following loop would allow the loop variable to take on a value of <code>array.length</code>, causing an IndexOutOfBoundsException to be thrown:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt;= array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("   [" + i + "] = " + array[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.lossOfPrecisionInCast">Loss of Precision in Cast</a></h4><p>
<b>Summary</b><br/>Casting to a lower precision type can cause loss of data.<p><b>Description</b><br/>This audit rule checks for places where one numeric type is being cast to another type of lower precision than the first. Doing so can result in a loss of data, which is generally not desirable.<p><b>Example</b><br/>Given a declaration of the form:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;double oneThird = 1.0 / 3.0;</code><p>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;(float) oneThird</code><h4><a name="com.instantiations.assist.eclipse.audit.missingConstantsInSwitch">Missing Constants In Switch</a></h4><p>
<b>Summary</b><br/>Switch statements should include all possible enumeration constants.<p><b>Description</b><br/>This audit rule checks for the existence of switch statements whose case labels are constants declared by an enum but which do not include all of the declared constants.<p><b>Example</b><br/>Given the following declarations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public enum PopcornSize {MEDIUM, LARGE, EXTRA_LARGE};<p>&nbsp;&nbsp;&nbsp;&nbsp;private PopcornSize size;</code><p>the following switch statement would be flagged as a violation because it does not contain a case label for EXTRA_LARGE:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (size) {<br>&nbsp;&nbsp;&nbsp;&nbsp;case MEDIUM:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promptForUgradeToLarge();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;case LARGE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promptForDrinksAndCandy();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_missing_constants_in_switch.gif" width="306" height="20"></p><h4><a name="com.instantiations.assist.eclipse.audit.missingDefaultInSwitch">Missing Default in Switch</a></h4><p>
<b>Summary</b><br/>Every switch statement should have a default clause.<p><b>Description</b><br/>This audit rule checks for the existence of a default case within every switch statement.<p><b>Example</b><br/>The following switch statement would be flagged as a violation because it does not contain a "default" case label:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (accountType) {<br>&nbsp;&nbsp;&nbsp;&nbsp;case CHECKING_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((CheckingAccount) account).getCheckingBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;case SAVINGS_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((SavingsAccount) account).getSavingsBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.missingStaticMethod">Missing static method in non-instantiable class</a></h4><p>
<b>Summary</b><br/>Non-instantiable classes should have at least one static method.<p><b>Description</b><br/>If a class has been made non-instantiable by making all constructors private, it should define at least one non-private static method, otherwise the class will be unusable.<p><b>Example</b><br/>The following would be flagged as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Foo() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_missing_static_method.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.missingUpdateInFor">Missing Update in For Statement</a></h4><p>
<b>Summary</b><br/>Every for statement should have an update clause.<p><b>Description</b><br/>This audit rule checks for the existence of an update clause within every for statement. If a for statement does not require an update clause it should be replaced by a while statement.<p><b>Example</b><br/>The following for statement would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator i = set.iterator(); i.hasNext(); ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object element = i.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.misspelledMethodName">Misspelled Method Name</a></h4><p>
<b>Summary</b><br/>Methods with incorrectly spelled names do not override the superclass method.<p><b>Description</b><br/>This rule detects small differences in spelling between methods defined in two different types in a hierarchy where both methods have the same parameter lists. Such methods may be intended to be identical but only the superclass method will be invoked.<p><img src="../../images/auditrules/audit_misspelled_method_name.gif" width="357" height="106"></p><h4><a name="com.instantiations.assist.eclipse.callNextWithoutHasNext">Next method invoked without hasNext method</a></h4><p>
<b>Summary</b><br/>Do not invoke the <code>next</code> method if you do not invoke <code>hasNext</code> method before that because NoSuchElementException can be thrown.<p><b>Description</b><br/>This rule looks for places where the <code>next</code> method is invoked without or before the <code>hasNext</code> method.<p><b>Security Implications</b><br/>If the <code>next</code> method is invoked without first invoking the <code>hasNext</code> method, in loop for example, a NoSuchElementException may be thrown.<p><b>Example</b><br/>The following invocation of the <code>next</code> method will be flagged as a violation because the <code>hasNext</code> method is not invoked:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod(Collection myList)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.......<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator iter = myList.iterator();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter.next();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.nonCaseLabelInSwitch">Non-case Label in Switch</a></h4><p>
<b>Summary</b><br/>Switch statements should only contain case labels.<p><b>Description</b><br/>This audit rule finds labels other that case labels that appear within a switch statement. Such labels are often the result of forgetting to type the keyword "case" rather than an intent to use a labeled statement. If it isn't the result of an accident, having a labeled statement in a switch statement makes the logic much harder to understand because it can easily be mistaken for a case label.<p><b>Example</b><br/>The statement labeled "SAVINGS_ACCOUNT" would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (accountType) {<br>&nbsp;&nbsp;&nbsp;&nbsp;case CHECKING_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((CheckingAccount) account).getCheckingBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;SAVINGS_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((SavingsAccount) account).getSavingsBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.nonTerminatedCaseClause">Non-terminated Case Clause</a></h4><p>
<b>Summary</b><br/>Case clauses should never fall through into the following case.<p><b>Description</b><br/>This audit rule checks for the existence of either a break, continue, return, or throw statement at the end of each case clause in a switch statement. The lack of either of these statements means that control will fall through to the next case, which is usually not what is intended. It is possible to configure this rule to also accept a user-defined comment (such as "no break") as a signal that the developer knew what was happening.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (accountType) {<br>&nbsp;&nbsp;&nbsp;&nbsp;case CHECKING_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((CheckingAccount) account).getCheckingBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;case SAVINGS_ACCOUNT:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance = ((SavingsAccount) account).getSavingsBalance();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_non_terminated_case_clause.gif" width="400" height="170"></p><h4><a name="com.instantiations.assist.eclipse.audit.overloadedEquals">Overloaded Equals</a></h4><p>
<b>Summary</b><br/>The equals method should always take a parameter of type Object.<p><b>Description</b><br/>This audit rule looks for declarations of the method equals whose single parameter has a declared type different from java.lang.Object. Overloading the equals method can easily lead to situations where a.equals(b) != b.equals(a).<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(String string) <br>&nbsp;&nbsp;&nbsp;&nbsp;{ <br>&nbsp;&nbsp;&nbsp;&nbsp;... <br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_overloaded_equals.gif" width="386" height="23"></p><h4><a name="com.instantiations.assist.eclipse.audit.overloadedMethods">Overloaded Methods</a></h4><p>
<b>Summary</b><br/>Overloading method names can cause confusion and errors.<p><b>Description</b><br/>This audit rule finds methods that are overloaded. Overloaded methods are methods that have the same name and the same number of parameters, but do not have the same types of parameters. Such methods can cause confusion and errors because it is not always obvious which method will be selected at run time.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public void process(Person person)<br>&nbsp;&nbsp;&nbsp;&nbsp;public void process(Employee employee)</code><h4><a name="com.instantiations.assist.eclipse.audit.possibleNullPointer">Possible Null Pointer</a></h4><p>
<b>Summary</b><br/>A pointer is being dereferenced when it might be null.<p><b>Description</b><br/>This rule identifies places where an object-valued variable is being dereferenced without first ensuring that it cannot be null.<p><b>Example</b><br/>Given the following method declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public String[] split(String string)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index = string.indexOf(":");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>The invocation of the indexOf method would be flagged.<h4><a name="com.instantiations.assist.eclipse.audit.potentialInfiniteLoop">Potential Infinite Loop</a></h4><p>
<b>Summary</b><br/>Some loops can be written in such a way that they will never terminate. This is bad practice, and usually not intended.<p><b>Description</b><br/>Loops can exit in several ways. Either their exit condition can be satisfied, an exception can be thrown, a value can be returned, or a <code>break</code> or a <code>continue</code> can transfer control out of the loop. In the body of the loop, something should happen to either modify the value of the exit condition, or modify the value of a condition leading to a return, throw, or branching statement.<p><b>Example</b><br/>The following would be flagged as a violation, since the value of <code>a</code> is not changed in the body of the loop. <p><code>&nbsp;&nbsp;&nbsp;&nbsp;int a = 0; int b = 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;while (a &lt; 10) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.recursiveCallWithNoCheck">Recursive Call With No Check</a></h4><p>
<b>Summary</b><br/>Don't recursively call a method without a conditional check.<p><b>Description</b><br/>This audit rule flags methods that recursively call themselves with no conditional check, or return escape. Violations are either infinite loops, or the logic of the method relies on exceptions being thrown. In the first case the infinite loop needs to be removed. In the second case, thrown exceptions should not be relied on as they are much more expensive than writing the equivalent conditional.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;private void countDownToZero(int i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print("i = " + i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i--;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countDownToZero(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// never reached!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.repeatedAssignment">Repeated Assignment</a></h4><p>
<b>Summary</b><br/>A single variable should not be assigned the same value multiple times.<p><b>Description</b><br/>This audit rule checks for multiple assignments of the same value to a single variable within the same statement.<p><b>Example</b><br/>The following assignment would be flagged because the variable x is assigned the same value twice:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = y = x = 0;</code><h4><a name="com.instantiations.assist.eclipse.audit.returnInFinally">Return in Finally</a></h4><p>
<b>Summary</b><br/>Finally blocks should not contain a return statement.<p><b>Description</b><br/>This audit rule finds places where a return statement is contained in a finally block.<p><b>Example</b><br/>The following return statement would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return array.length;</code><h4><a name="com.instantiations.assist.eclipse.audit.stringIndexOfUse">String indexOf Use</a></h4><p>
<b>Summary</b><br/>Don't compare output from String.indexOf with &gt; 0 or &lt;= 0.<p><b>Description</b><br/>This audit rule looks for the common off-by-one-error caused by comparing String.indexOf() to 0, for example: "indexOf(..) &gt; 0." This is read as "if indexOf is greater than 0 then the there doesn't exist an instance of what we are looking for", but the mistake here is that indexOf returns -1 if nothing was found, not 0. Hence, the user meant "&gt;=", not "&gt;". The opposite mistake is made with "indexOf &lt;= 0."<p>All "indexOf" methods in java.lang.String are detected by this rule, see indexOf(int), indexOf(int, int), lastIndexOf(int), lastIndexOf(int, int), indexOf(String), etc.<p><b>Example</b><br/>The following comparison would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;str.indexOf('.') &gt; 0</code><h4><a name="com.instantiations.assist.eclipse.subClassShouldOverrideMethod">Subclass should override method</a></h4><p>
<b>Summary</b><br/>If you want to override a method declared in a superclass, you should not change the signature of a method which belongs to the subclass.<p><b>Description</b><br/>This rule looks for places where a method of defined in a subclass has the same name as a method defined in a superclass but a different signature.<p><b>Security Implications</b><br/>If you want to override the method in the superclass, you should change signature method which belongs to subclass.<p><b>Example</b><br/>The following invocation method which belongs to subclass will be flagged as a violation because a signatures do not match.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Parent<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void func(int a) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.........<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public class Child extends Parent<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void func(double a) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.throwInFinally">Throw in Finally</a></h4><p>
<b>Summary</b><br/>Finally blocks should not contain a throw statement.<p><b>Description</b><br/>This audit rule finds places where a throw statement is contained in a finally block.<p><b>Example</b><br/>The following throw statement would be flagged as a violation because it occurs within a finally block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Exception("This is never OK");<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.unassignedField">Unassigned Field</a></h4><p>
<b>Summary</b><br/>Private fields should be assigned a value.<p><b>Description</b><br/>This audit rule looks for private fields that are never assigned a value.<h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryInstanceof">Unnecessary "instanceof" Test</a></h4><p>
<b>Summary</b><br/>Unnecessary instanceof tests should be removed.<p><b>Description</b><br/>This audit rule looks for unnecessary uses of "instanceof". An "instanceof" test against a superclass or superinterface of the static type of an object is unnecessary and should be removed.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;"this is a string" instanceof String;</code><h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryNullCheck">Unnecessary Null Check</a></h4><p>
<b>Summary</b><br/>A variable is being checked against null when it is not necessary.<p><b>Description</b><br/>This rule identifies places where an object-valued variable is being compared to null when the comparison is unnecessary because of preceding code.<p><b>Example</b><br/>The following comparison would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;airplane.prepareForTakeOff();<br>&nbsp;&nbsp;&nbsp;&nbsp;if (airplane != null) ...</code><h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryReturn">Unnecessary Return</a></h4><p>
<b>Summary</b><br/>Methods that do not return a value should not end with a return.<p><b>Description</b><br/>This audit rule finds methods that are declared to not return a value (void) but whose last statement is a return statement.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public void markChanged()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changed = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.unusedReturnValue">Unused Return Value</a></h4><p>
<b>Summary</b><br/>The value returned from methods should be used.<p><b>Description</b><br/>This audit rule looks for invocations of methods that return values where the value is ignored. Most methods that return a value either have no side-effect or are using the returned value as an indication of success or failure. In the first case, the invocation should be removed if the value is not needed. In the second case, the status value should be checked.<p><b>Example</b><br/>The following method invocation would be flagged as a violation if the method <code>getX</code> returns a value:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;point.getX();</code><p><img src="../../images/auditrules/audit_unused_return_value.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.unusedStringBuffer">Unused StringBuffer</a></h4><p>
<b>Summary</b><br/>The contents of a StringBuffer should be used.<p><b>Description</b><br/>This audit rule checks for any instances of the class StringBuffer whose contents are not retrieved. This usually means that the code to use the contents of the buffer was omitted, but can also indicate that old code is no longer needed and should have been deleted.<br><b>Example</b><br/>The StringBuffer declared in the following method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private String toString()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer buffer;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = new StringBuffer();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.append("Product #");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer.append(getName());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getName();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unusedStringBuilder">Unused StringBuilder</a></h4><p>
<b>Summary</b><br/>The contents of a StringBuilder should be used.<p><b>Description</b><br/>This audit rule checks for any instances of the class StringBuilder whose contents are not retrieved. This usually means that the code to use the contents of the builder was omitted, but can also indicate that old code is no longer needed and should have been deleted.<br><b>Example</b><br/>The StringBuilder declared in the following method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private String toString()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder builder;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder = new StringBuilder();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.append("Product #");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.append(getName());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getName();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.usageOfBinaryComparison">Usage Of Binary Comparison</a></h4><p>
<b>Summary</b><br/>You should use short-circuit operations instead of binary operations.<p><b>Description</b><br/>This rule looks for places where a binary operation is used that could be replaced by a short-circuit operator.<p><b>Security Implications</b><br/>Usage of binary operation instead of short-circuit can cause unexpected situation when RuntimeException or NullPointerException can be thrown.<p><b>Example</b><br/>The following code would be flagged as a violation because a binary and operator (&amp;) is used where a conditional-and operator (&amp;&amp;) could be used:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void func(int[] a)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a != null &amp; a.length() != 0) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useIdentityToCompareNull">Use == to Compare With null</a></h4><p>
<b>Summary</b><br/>A null value should not be compared using methods equals() or equalsIgnoreCase().<p><b>Description</b><br/>This audit rule finds places where an object is compared to the null value using either the equals() or (if the object is a String) the equalsIgnoreCase() method. In both cases, the contract of the method requires this comparison to always return false. Either the test is unnecessary, or it should be replaced by an identity comparison.<p><b>Example</b><br/>The following comparison would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (object.equals(null)) </code><h4><a name="com.instantiations.eclipse.analysis.audit.security.variableShouldNotHaveNullValue">Variable Has Null Value</a></h4><p>
<b>Summary</b><br/>A variable that is guaranteed to have a null value and is used in an expression may indicate that the programmer forgot to initialize variable with its actual value.<p><b>Description</b><br/>This rule looks for a places where variables with <code>null</code> values are used in an expression.<p><b>Security Implications</b><br/>Such an error may indicate a flaw in the program's logic that may leave the software vulnerable if present in the security-sensitive part of an application.<p><b>Example</b><br/>The following usage of variable should be marked as violation because the variable is always <code>null</code>:<p>&nbsp;&nbsp;&nbsp;&nbsp;public boolean myMethod(String param)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String tmp = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tmp.equals(param)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.variableUsage">Variable Usage</a></h4><p>
<b>Summary</b><br/>Variables should never shadow variables with the same name that are defined in an outer scope.<p><b>Description</b><br/>This audit rule checks for any declarations of variables that shadow a variable with the same name that is defined in an outer scope.<p><b>Example</b><br/>In a class with a field declaration such as:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private int inventoryCount;</code><p>the following parameter would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void printInventory(int inventoryCount)</code><p><img src="../../images/auditrules/audit_variable_usage.gif" width="300" height="140"></p></body>
</html>
