<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Threads and Synchronization</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Threads and Synchronization</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for possible problems having to do with the use of threads and synchronization.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.concurrentModification">Concurrent Modification</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.fieldAccessProtection">Field Access Protection</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedNotify">Mismatched Notify</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedWait">Mismatched Wait</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unatomicFileOperations">Non-atomic File Operations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.startMethodInvokedInConstructor">Start Method Invoked In Constructor</a></li>
      <li><a href="#com.instantiations.assist.eclipse.synchronizationOnGetClassMethod">Synchronization On getClass Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.usageOfStaticCalendar">Usage Of Static Calendar</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.usageOFStaticDateFormat">Usage Of Static Date Format</a></li>
      <li><a href="#com.instantiations.assist.eclipse.waitInvokedInsteadOfAwait">wait() Invoked Instead of await()</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.concurrentModification">Concurrent Modification</a></h4><p>
<b>Summary</b><br/>Removing from the collection being iterated over and continuing iteration afterwards results in an exception.<p><b>Description</b><br/>This audit rule violates the cases when elements are removed from a collection while still iterating over it. Precisely, calling <code>Iterator#next()</code> after <code>remove()</code> was called results in an exception. Correct way of dealing with a necessity to do so is to iterate over the duplicate of a collection while removing found objects from the original or to use the iterators <code>remove()</code> method if it is known to be supported.<p><b>Security Implications</b><br/>For fail-fast collections concurrent modifications result in <code>ConcurrentModificationException</code>, which could create an unexpected situation in the code execution and thus be a potential security threat.<p><b>Example</b><br/>The following method removes elements from a collection while iterating over it and thus would be marked as violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void removeByPattern(Collection c, String pattern) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator i = c.iterator(); i.hasNext();) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String val = (String) i.next();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (val.contains(pattern)) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.remove(val);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.fieldAccessProtection">Field Access Protection</a></h4><p>
<b>Summary</b><br/>When a field that is usually accessed in a synchronized context is accessed without synchronization, this indicates an error.<p><b>Description</b><br/>This audit rule looks for unsynchronized accesses to fields that are usually accessed in a synchronized way. A field is considered to match the criteria if synchronization is used to access it in at least 66% of all of the places in which it is accessed.<p><b>Security Implications</b><br/>Partial or incomplete synchronization is the primary source of all deadlocks and race conditions. Multi-threaded parts of data should always be accessed in a synchronized block.<p><b>Example</b><br/>The following class appears to provide synchronized access to the internal list, but <code>remove()</code> method is not synchronized and thus will be marked as violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SynchronizedList {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final List data = new ArrayList();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void add(Object item) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.add(item);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized int size() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data.size();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized Object pop() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data.remove(0);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void remove(Object item) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.remove(item);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedNotify">Mismatched Notify</a></h4><p>
<b>Summary</b><br>Do not use <code>notify()</code> or <code>notifyAll()</code> methods without holding locks.<p><b>Description</b><br>This audit rule looks for invocations of <code>notify()</code> or <code>notifyAll()</code> methods without holding a lock on the object.<p><b>Security Implications</b><br>Invoking <code>notify()</code> or <code>notifyAll()</code> without holding a lock can lead to throwing an <code>IllegalMonitorStateException</code>.<p><b>Example</b><br>The following invocation of the <code>notify()</code> method will be marked as a violation because the container method is not <code>synchronized</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void method() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedWait">Mismatched Wait</a></h4><p>
<b>Summary</b><br>Do not use <code>wait()</code> method without holding locks.<p><b>Description</b><br>This audit rule looks for invocations of the <code>wait()</code> method without holding a lock on the object.<p><b>Security Implications</b><br>Invoking <code>wait()</code> without holding a lock can lead to throwing an <code>IllegalMonitorStateException</code>.<p><b>Example</b><br>The following invocation of the <code>wait</code> method will be marked as a violation because the container method is not <code>synchronized</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void method(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></h4><p>
<b>Summary</b><br/>Invoking one synchronized method of an object from another synchronized method of the same object affects the performance of an application.<p><b>Description</b><br/>This audit rule looks for invocations of a synchronized method from another synchronized method in the same class.<p><b>Security Implications</b><br/>Such calls both affect the performance of an application and indicate a poorly designed synchronization aspect of the code, which usually results in synchronization errors that could be exploited to create unexpected states of an application.<p><b>Example</b><br/>The following code would be flagged as a violation because it invokes one synchronized method of an object from another synchronized method of the same object:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SyncDataSource {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized Object getData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return internalGetData();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private synchronized Object internalGetData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unatomicFileOperations">Non-atomic File Operations</a></h4><p>
<b>Summary</b><br/>Checking a file for existence and then writing into it is a non-atomic operation, the assumption about it being atomic may fail, leading to unexpected consequences.<p><b>Description</b><br/>This audit rule looks for conditional decisions made on the basis of an invocation of <code>java.io.File.exists()</code>.<p><b>Security Implications</b><br/>Calling <code>exists()</code> and then performing some file operation based on the result of this call is a non-atomic operation, i.e. the file state of existence can change in the gap of time between <code>exists()</code> call and the subsequent actions. This may result in an unexpected behavior of an application that could possibly compromise its security.<p><b>Example</b><br/>The following code would be flagged as a violation because it makes a file writing decision based on the result of <code>exists()</code> call:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;File lock = new File(".lock");<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (!lock.exists()) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.createNewFile();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.delete();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.startMethodInvokedInConstructor">Start Method Invoked In Constructor</a></h4><p>
<b>Summary</b><br>Do not invoke <code>java.lang.Thread.start()</code> method inside constructors.<p><b>Description</b><br>This audit rule looks for invocations of <code>java.lang.Thread.start()</code> method inside constructors.<p><b>Security Implications</b><br>If the class is extended/subclassed, the method <code>start()</code> will be invoked before the constructor of the subclass has finished, potentially allowing the new thread to see the object in an inconsistent state.<p><b>Example</b><br>The following invocation of the <code>start</code> method will be marked as a violation because it is called inside the constructor:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SimleClass {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public SimleClass() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Thread() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.synchronizationOnGetClassMethod">Synchronization On getClass Method</a></h4><p>
<b>Summary</b><br>You should avoid synchronization on <code>getClass()</code> method.<p><b>Description</b><br>This rule looks for places where the result of the <code>getClass()</code> method is used for synchronization.<p><b>Security Implications</b><br>If this class is subclassed, subclasses will synchronize on a different class object, which isn't likely what was intended.<p><b>Example</b><br>The following code is synchronized on <code>getClass</code> method and thuswill be marked as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void methodOne(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized ( getClass() ){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.usageOfStaticCalendar">Usage Of Static Calendar</a></h4><p>
<b>Summary</b><br>Do not use <code>Calendar</code> objects without synchronization.<p><b>Description</b><br>This rule looks for a places where <code>Calendar</code> objects are used without synchronization.<p><b>Security Implications</b><br><code>Calendars</code> are inherently unsafe for multithread usage. If this object is used without proper synchronizations, <code>ArrayIndexOutOfBoundsException</code> can be thrown.<p><b>Example</b><br>The following usage of a <code>Calendar</code> object will be marked as a violation because it should be used in <code>synchronized</code> block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private static Calendar data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;public Calendar getCalendar() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.usageOFStaticDateFormat">Usage Of Static Date Format</a></h4><p>
<b>Summary</b><br>Do not use <code>DateFormat</code> objects without synchronization.<p><b>Description</b><br>This rule looks for places where a <code>DateFormat</code> object is used without synchronization.<p><b>Security Implications</b><br><code>DateFormat</code>s are inherently unsafe for multithread usage. Sharing a single instance across thread boundaries without proper synchronization can result in erratic behavior of the application.<p><b>Example</b><br>The following usage of a <code>DateFormat</code> object will be marked as a violation because it should be used in a <code>synchronized</code> block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private static DateFormat data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;public DateFormat getFormat() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.waitInvokedInsteadOfAwait">wait() Invoked Instead of await()</a></h4><p>
<b>Summary</b><br/>If class is subtype of <code>java.util.concurrent.locks.Condition</code> you should use await method instead of wait method.<p><b>Description</b><br/>This audit rule looks for places where the <code>wait()</code> method is invoked on a <code>java.util.concurrent.locks.Condition</code> object.<p><b>Security Implications</b><br/>Invoking the <code>wait()</code> method on a <code>java.util.concurrent.locks.Condition</code> object is usually a mistake. This class is specially used for synchronization and provides the method await(), similar to wait() in its name. Accidentially calling wait() instead is a plain error which will result in the application behaving in an unexpected way and possibly becoming vulnurable to an attack. Asynchronous environment is especially vulnurable to such errors as deadlock may occur and ultimately lead to denial-of-service state.<p><b>Example</b><br/>The following code will be marked as a violation because the <code>wait()</code> method used:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void  myFunction( Condition cond )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cond.wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( InterruptException e){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
