<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Threads and Synchronization</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Threads and Synchronization</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for possible problems having to do with the use of threads and synchronization.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.callLockWithoutUnlock">Call Lock Without Unlock</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.concurrentModification">Concurrent Modification</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowNotifyUsage">Disallow Notify Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowSleepInsideWhile">Disallow Sleep Inside While</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowSleepUsage">Disallow Sleep Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowThreadGroupUsage">Disallow ThreadGroup Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowUnnamedThreadUsage">Disallow Unnamed Thread Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowDeprecatedMethodUsage">Disallow Use of Deprecated Thread Methods</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowYieldUsage">Disallow Yield Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.doNotCatchIllegalMonitorStateException">Do not Catch IllegalMonitorStateException</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.doubleCheckLocking">Double Check Locking</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.fieldAccessProtection">Field Access Protection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useOfThreadInterrupted">Improper Use of Thread.interrupted()</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedNotify">Mismatched Notify</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedWait">Mismatched Wait</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.noRunMethod">No Run Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unatomicFileOperations">Non-atomic File Operations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.callNotifyInDoubleLocks">Notify method invoked while two locks are held</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.overridingSynchronizedMethod">Overriding a Synchronized Method with a Non-synchronized Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.callSleepInLocks">Sleep method invoked in synchronized code</a></li>
      <li><a href="#com.instantiations.assist.eclipse.startMethodInvokedInConstructor">Start Method Invoked In Constructor</a></li>
      <li><a href="#com.instantiations.assist.eclipse.synchronizationOnGetClassMethod">Synchronization On getClass Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.synchronizationOnNonFinalFields">Synchronization On Non Final Fields</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.synchronizedMethod">Synchronized Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.usageOfStaticCalendar">Usage Of Static Calendar</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.usageOFStaticDateFormat">Usage Of Static Date Format</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useStartRatherThanRun">Use Start Rather Than Run</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useThreadSafeLazyInitialization">Use Thread-safe Lazy Initialization</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.waitInsideWhile">Wait Inside While</a></li>
      <li><a href="#com.instantiations.assist.eclipse.callWaitInDoubleLocks">Wait method invoked while two locks are held</a></li>
      <li><a href="#com.instantiations.assist.eclipse.waitInvokedInsteadOfAwait">wait() Invoked Instead of await()</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.callLockWithoutUnlock">Call Lock Without Unlock</a></h4><p>
<b>Summary</b><br/>Invoke unlock() method in catch clause or finally block.<p><b>Description</b><br/>This audit rule looks for places where the <code>lock()</code> method is invoked without guaranteeing that the <code>unlock()</code> method will be invoked if an exception is thrown.<p><b>Security Implications</b><br/>Such a mistake can cause a deadlock in the case of an exception. Deadlocks are a common way of depleting a web application's pool of threads and thus permitting a denial-of-service attack.<p><b>Example</b><br/>The following invocation of the <code>lock()</code> method will be flagged as a violation because the <code>unlock()</code> method is not invoked if an exception is thrown:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.......<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lock l = new Lock();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.lock();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter.next();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception e)&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.unlock();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.concurrentModification">Concurrent Modification</a></h4><p>
<b>Summary</b><br/>Removing from the collection being iterated over and continuing iteration afterwards results in an exception.<p><b>Description</b><br/>This audit rule violates the cases when elements are removed from a collection while still iterating over it. Precisely, calling <code>Iterator#next()</code> after <code>remove()</code> was called results in an exception. Correct way of dealing with a necessity to do so is to iterate over the duplicate of a collection while removing found objects from the original or to use the iterators <code>remove()</code> method if it is known to be supported.<p><b>Security Implications</b><br/>For fail-fast collections concurrent modifications result in <code>ConcurrentModificationException</code>, which could create an unexpected situation in the code execution and thus be a potential security threat.<p><b>Example</b><br/>The following method removes elements from a collection while iterating over it and thus would be marked as violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void removeByPattern(Collection c, String pattern) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator i = c.iterator(); i.hasNext();) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String val = (String) i.next();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (val.contains(pattern)) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.remove(val);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowNotifyUsage">Disallow Notify Usage</a></h4><p>
<b>Summary</b><br/>The notify() method should not be used.<p><b>Description</b><br/>The method notifyAll() should be used rather than notify() because it will generally lead to a better scheduling of waiting threads.<p><b>Example</b><br/>The following invocation of the notify() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;synchronize (monitor) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitor.notify();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowSleepInsideWhile">Disallow Sleep Inside While</a></h4><p>
<b>Summary</b><br/>The sleep() method should not be used within a while loop.<p><b>Description</b><br/>This audit rule looks for invocations of the sleep() method that occur inside of a while loop. Such occurrences usually indicate that the code implements a busy-wait loop, which is inefficient. Instead, the code should use wait() and notify() to block the thread until it is possible for execution to proceed.<p><b>Example</b><br/>The following invocation of the sleep() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;while (eventQueue.isEmpty()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowSleepUsage">Disallow Sleep Usage</a></h4><p>
<b>Summary</b><br/>The sleep() method should not be used.<p><b>Description</b><br/>This audit rule looks for invocations of the method Thread.sleep(). If you are waiting for some specific state to be reached, you should instead use the wait() method so that you can be notified when the state has been reached. This will improve both the performance and reliability of your code. <p><b>Example</b><br/>The following invocation of the sleep() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;sleep(1000);</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowThreadGroupUsage">Disallow ThreadGroup Usage</a></h4><p>
<b>Summary</b><br/>The class ThreadGroup should not be used.<p><b>Description</b><br/>The class ThreadGroup should not be used in multi-threaded applications because its implementation is not thread safe.<p><b>Example</b><br/>The following instance creation would be flagged as a violation because it is creating an instance of the class java.lang.ThreadGroup:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new ThreadGroup("Background Threads")</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowUnnamedThreadUsage">Disallow Unnamed Thread Usage</a></h4><p>
<b>Summary</b><br/>Threads should be named to aid in debugging.<p><b>Description</b><br/>This audit rule looks for the creation of threads that are not given a name. Threads should be named in order to make it easier to debug the application.<p><b>Example</b><br/>The following thread creation would be flagged as a violation because a name is not provided:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Thread(new Runnable() { ... });</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowDeprecatedMethodUsage">Disallow Use of Deprecated Thread Methods</a></h4><p>
<b>Summary</b><br/>Don't use deprecated methods when writing multi-threaded code.<p><b>Description</b><br/>The methods Thread.resume(), Thread.stop(), Thread.suspend(), Thread.destroy() and Runtime.runFinalizersOnExit() have been deprecated and should not be used because they are inherently unsafe.<p><b>Example</b><br/>The following use of the suspend() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;processingThread.suspend();</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowYieldUsage">Disallow Yield Usage</a></h4><p>
<b>Summary</b><br/>The method Thread.yield() should not be used.<p><b>Description</b><br/>The method Thread.yield() should not be used because its behavior is not consistent across all platforms.<p><b>Example</b><br/>The following invocation of the yield() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;backgroundTask.yield();</code><h4><a name="com.instantiations.assist.eclipse.audit.doNotCatchIllegalMonitorStateException">Do not Catch IllegalMonitorStateException</a></h4><p>
<b>Summary</b><br/>Catching an IllegalMonitorStateException indicates a concurrency handling error in debug.<p><b>Description</b><br/>This audit rule looks for code that attempts to catch <code>IllegalMonitorStateException</code>.<p><b>Security Implications</b><br/>Catching an <code>IllegalMonitorStateException</code> indicates a concurrency handing flaw in the design of an application which is only partially mitigated, but not avoided. This design flaw could be exploited to bring an application to a denial of service state or even provide security-sensitive data, such as parts of an application design, to the attacker.<p><b>Example</b><br/>The following code would be flagged as a violation because it catches <code>IllegalMonitorStateException</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalMonitorStateException e ) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><br><h4><a name="com.instantiations.assist.eclipse.audit.doubleCheckLocking">Double Check Locking</a></h4><p>
<b>Summary</b><br/>Double Check Locking singleton synchronization technique should not be used.<p><b>Description</b><br/>Double-checked locking is a widespread practice used in Singleton pattern implementations. It is supposed to provide a safe way for the lazy initialization of the singleton in a multi-threaded environment combined with performance optimization. But in some cases this code will not work as intended, leading to concurrency problems and unpredictable behavior. This pattern should not be used.<p><b>Security Implications</b><br/>in some cases double-checked locking will not work as intended, leading to concurrency problems and unpredictable behavior.<p><b>Example</b><br/>The following code would be flagged as a violation because it uses the double-checked locking pattern:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Sample {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private List data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public List getData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data == null) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (this) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (data == null) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = new ArrayList();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.fieldAccessProtection">Field Access Protection</a></h4><p>
<b>Summary</b><br/>When a field that is usually accessed in a synchronized context is accessed without synchronization, this indicates an error.<p><b>Description</b><br/>This audit rule looks for unsynchronized accesses to fields that are usually accessed in a synchronized way. A field is considered to match the criteria if synchronization is used to access it in at least 66% of all of the places in which it is accessed.<p><b>Security Implications</b><br/>Partial or incomplete synchronization is the primary source of all deadlocks and race conditions. Multi-threaded parts of data should always be accessed in a synchronized block.<p><b>Example</b><br/>The following class appears to provide synchronized access to the internal list, but <code>remove()</code> method is not synchronized and thus will be marked as violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SynchronizedList {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final List data = new ArrayList();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void add(Object item) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.add(item);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized int size() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data.size();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized Object pop() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data.remove(0);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void remove(Object item) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data.remove(item);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useOfThreadInterrupted">Improper Use of Thread.interrupted()</a></h4><p>
<b>Summary</b><br/>The static method <code>Thread.interrupted()</code> can be easily confused with the instance method <code>isInterrupted()</code>.<p><b>Description</b><br/>Since <code>interrupted()</code> is a static method which returns whether the <i>current</i> thread is interrupted, it should always be invoked using <code>Thread.interrupted()</code>. This audit rule looks for any invocations of <code>interrupted()</code> on instances of <code>Thread</code>.instead.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Thread().interrupted()</code><h4><a name="com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedNotify">Mismatched Notify</a></h4><p>
<b>Summary</b><br>Do not use <code>notify()</code> or <code>notifyAll()</code> methods without holding locks.<p><b>Description</b><br>This audit rule looks for invocations of <code>notify()</code> or <code>notifyAll()</code> methods without holding a lock on the object.<p><b>Security Implications</b><br>Invoking <code>notify()</code> or <code>notifyAll()</code> without holding a lock can lead to throwing an <code>IllegalMonitorStateException</code>.<p><b>Example</b><br>The following invocation of the <code>notify()</code> method will be marked as a violation because the container method is not <code>synchronized</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void method() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.eclipse.analysis.audit.security.rule.threadsAndSynchronization.mismatchedWait">Mismatched Wait</a></h4><p>
<b>Summary</b><br>Do not use <code>wait()</code> method without holding locks.<p><b>Description</b><br>This audit rule looks for invocations of the <code>wait()</code> method without holding a lock on the object.<p><b>Security Implications</b><br>Invoking <code>wait()</code> without holding a lock can lead to throwing an <code>IllegalMonitorStateException</code>.<p><b>Example</b><br>The following invocation of the <code>wait</code> method will be marked as a violation because the container method is not <code>synchronized</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void method(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></h4><p>
<b>Summary</b><br/>Invoking one synchronized method of an object from another synchronized method of the same object affects the performance of an application.<p><b>Description</b><br/>This audit rule looks for invocations of a synchronized method from another synchronized method in the same class.<p><b>Security Implications</b><br/>Such calls both affect the performance of an application and indicate a poorly designed synchronization aspect of the code, which usually results in synchronization errors that could be exploited to create unexpected states of an application.<p><b>Example</b><br/>The following code would be flagged as a violation because it invokes one synchronized method of an object from another synchronized method of the same object:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SyncDataSource {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized Object getData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return internalGetData();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private synchronized Object internalGetData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.noRunMethod">No Run Method</a></h4><p>
<b>Summary</b><br/>Subclasses of Thread should implement the run() method.<p><b>Description</b><br/>Subclasses of Thread should implement the run() method so that they will have the behavior for which they were created.<p><b>Example</b><br/>The following class will be flagged as a violation because it does not implement a run() method even though it subclasses java.lang.Thread:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SuperThread extends Thread<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unatomicFileOperations">Non-atomic File Operations</a></h4><p>
<b>Summary</b><br/>Checking a file for existence and then writing into it is a non-atomic operation, the assumption about it being atomic may fail, leading to unexpected consequences.<p><b>Description</b><br/>This audit rule looks for conditional decisions made on the basis of an invocation of <code>java.io.File.exists()</code>.<p><b>Security Implications</b><br/>Calling <code>exists()</code> and then performing some file operation based on the result of this call is a non-atomic operation, i.e. the file state of existence can change in the gap of time between <code>exists()</code> call and the subsequent actions. This may result in an unexpected behavior of an application that could possibly compromise its security.<p><b>Example</b><br/>The following code would be flagged as a violation because it makes a file writing decision based on the result of <code>exists()</code> call:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;File lock = new File(".lock");<br/>&nbsp;&nbsp;&nbsp;&nbsp;if (!lock.exists()) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.createNewFile();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.delete();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.callNotifyInDoubleLocks">Notify method invoked while two locks are held</a></h4><p>
<b>Summary</b><br/>Do not invoke the <code>notify</code> or <code>notifyAll</code> methods while two locks are being held.<p><b>Description</b><br/>This rule looks for places where the code invokes either <code>notify()</code> or <code>notifyAll()</code> while two locks are held.<p><b>Security Implications</b><br/>If this notification is intended to wake up a <code>wait()</code> that is holding the same locks, it might deadlock. The wait will only give up one lock and the notify will be unable to get both locks, and thus the notify will not succeed.<p><b>Example</b><br/>The following invocation of the <code>notify</code> method will be flagged as a violation because two lock are being held.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void myMethod(Object obj)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronize (obj) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.notify();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.overridingSynchronizedMethod">Overriding a Synchronized Method with a Non-synchronized Method</a></h4><p>
<b>Summary</b><br/>A non-synchronized method should not override a synchronized method.<p><b>Description</b><br/>This audit rule finds non-synchronized methods that override a synchronized method. Such a case usually indicates thread-unsafe code.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Widget<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized int getPartCount()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>The method getPartCount() would be flagged as a violation in the following class:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class CompositeWidget extends Widget<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int getPartCount()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return children.size();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.callSleepInLocks">Sleep method invoked in synchronized code</a></h4><p>
<b>Summary</b><br/>Do not invoke the sleep method while a lock is held.<p><b>Description</b><br/>This rule looks for places where the code invokes the method <code>sleep(long)</code> while a lock is held.<p><b>Security Implications</b><br/>An invocation of the sleep method while a lock is being held could lead to very poor performance or deadlock. Use the wait method instead of the sleep method.<p><b>Example</b><br/>The following invocation of the <code>sleep()</code> method will be flagged as a violation because a lock is being held.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void myMethod(Object obj)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.startMethodInvokedInConstructor">Start Method Invoked In Constructor</a></h4><p>
<b>Summary</b><br>Do not invoke <code>java.lang.Thread.start()</code> method inside constructors.<p><b>Description</b><br>This audit rule looks for invocations of <code>java.lang.Thread.start()</code> method inside constructors.<p><b>Security Implications</b><br>If the class is extended/subclassed, the method <code>start()</code> will be invoked before the constructor of the subclass has finished, potentially allowing the new thread to see the object in an inconsistent state.<p><b>Example</b><br>The following invocation of the <code>start</code> method will be marked as a violation because it is called inside the constructor:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SimleClass {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public SimleClass() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Thread() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.start();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.synchronizationOnGetClassMethod">Synchronization On getClass Method</a></h4><p>
<b>Summary</b><br>You should avoid synchronization on <code>getClass()</code> method.<p><b>Description</b><br>This rule looks for places where the result of the <code>getClass()</code> method is used for synchronization.<p><b>Security Implications</b><br>If this class is subclassed, subclasses will synchronize on a different class object, which isn't likely what was intended.<p><b>Example</b><br>The following code is synchronized on <code>getClass</code> method and thuswill be marked as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void methodOne(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized ( getClass() ){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.synchronizationOnNonFinalFields">Synchronization On Non Final Fields</a></h4><p>
<b>Summary</b><br/>All fields used for synchronization of threads should be declared final.<p><b>Description</b><br/>This rule looks for places where blocks are synchronized on non-final fields.<p><b>Security Implications</b><br/>If an attacker gets access to the field which is used for synchronization, he could modify it and create an error in synchronization logic. Such vulnerability could result in an application misbehaviour or crash or access to otherwise protected data.<p><b>Example</b><br/>The following code will be flagged as a violation because the field that is used for synchronization is not final.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Test {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object lock;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOUF(Object lock) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lock = lock;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(lock) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.synchronizedMethod">Synchronized Method</a></h4><p>
<b>Summary</b><br/>Methods should never be marked as synchronized.<p><b>Description</b><br/>This audit rule reports the use of the synchronized modifier with methods. It is too easy to miss the existence of the synchronized modifier, so following this rule leads to more readable code.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public synchronized String getName()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img border="0" src="../../images/auditrules/audit_synchronized_method.gif" width="237" height="24"></p><h4><a name="com.instantiations.assist.eclipse.audit.usageOfStaticCalendar">Usage Of Static Calendar</a></h4><p>
<b>Summary</b><br>Do not use <code>Calendar</code> objects without synchronization.<p><b>Description</b><br>This rule looks for a places where <code>Calendar</code> objects are used without synchronization.<p><b>Security Implications</b><br><code>Calendars</code> are inherently unsafe for multithread usage. If this object is used without proper synchronizations, <code>ArrayIndexOutOfBoundsException</code> can be thrown.<p><b>Example</b><br>The following usage of a <code>Calendar</code> object will be marked as a violation because it should be used in <code>synchronized</code> block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private static Calendar data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;public Calendar getCalendar() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.usageOFStaticDateFormat">Usage Of Static Date Format</a></h4><p>
<b>Summary</b><br>Do not use <code>DateFormat</code> objects without synchronization.<p><b>Description</b><br>This rule looks for places where a <code>DateFormat</code> object is used without synchronization.<p><b>Security Implications</b><br><code>DateFormat</code>s are inherently unsafe for multithread usage. Sharing a single instance across thread boundaries without proper synchronization can result in erratic behavior of the application.<p><b>Example</b><br>The following usage of a <code>DateFormat</code> object will be marked as a violation because it should be used in a <code>synchronized</code> block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private static DateFormat data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;public DateFormat getFormat() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/></code><h4><a name="com.instantiations.assist.eclipse.audit.useStartRatherThanRun">Use Start Rather Than Run</a></h4><p>
<b>Summary</b><br/>Threads should be started rather than run.<p><b>Description</b><br/>This audit rule looks for places where a thread is run using the run() method, rather than started using the start() method. This is usually a mistake since it causes the run() method to be run in the calling thread rather than in a newly spawned thread.<p><b>Example</b><br/>The following invocation would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;thread.run();</code><h4><a name="com.instantiations.assist.eclipse.audit.useThreadSafeLazyInitialization">Use Thread-safe Lazy Initialization</a></h4><p>
<b>Summary</b><br/>Static fields should be initialized in a thread safe way.<p><b>Description</b><br/>Static fields are typically initialized either as part of their declaration, in a static initializer, or lazily in a static method. The first two ways are thread safe because of the way the JVM initializes classes. In order for the initialization of a lazily initialized field (such as the unique instance of a Singleton class) to be thread safe, either the method must be synchronized or the body of the method must be inside a synchronize statement. If not, and if the method is called by multiple threads, one of the threads might get a reference to the field before it is fully initialized or it might be initialized multiple times. This audit rule looks for places where a static field is initialized in a way that is not thread safe.<p><b>Example</b><br/>The following singleton is not thread-safe, and would be marked as a violation.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MySingleton {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public MySingleton instance = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public MySingleton getInstance() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (instance == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance = new MySingleton();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return instance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private MySingleton() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<h4><a name="com.instantiations.assist.eclipse.audit.waitInsideWhile">Wait Inside While</a></h4><p>
<b>Summary</b><br/>The wait() method should only be invoked within a while loop.<p><b>Description</b><br/>This audit rule looks for invocations of the wait() method that occur outside of a while loop.<p><b>Example</b><br/>The following invocation of the wait() method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void waitForEvent()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronize (eventQueue) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventQueue.wait();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.callWaitInDoubleLocks">Wait method invoked while two locks are held</a></h4><p>
<b>Summary</b><br/>Do not invoke the <code>wait</code> method while two locks are being held.<p><b>Description</b><br/>This rule looks for places where the code invokes the <code>wait()</code> method while two locks are held.<p><b>Security Implications</b><br/>Situation when some threads wait on monitor while two locks are held can lead to deadlock.<p><b>Example</b><br/>The following invocation of the <code>wait</code> method will be flagged as a violation because two lock are being held.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void myMethod(Object obj)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronize (obj) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.waitInvokedInsteadOfAwait">wait() Invoked Instead of await()</a></h4><p>
<b>Summary</b><br/>If class is subtype of <code>java.util.concurrent.locks.Condition</code> you should use await method instead of wait method.<p><b>Description</b><br/>This audit rule looks for places where the <code>wait()</code> method is invoked on a <code>java.util.concurrent.locks.Condition</code> object.<p><b>Security Implications</b><br/>Invoking the <code>wait()</code> method on a <code>java.util.concurrent.locks.Condition</code> object is usually a mistake. This class is specially used for synchronization and provides the method await(), similar to wait() in its name. Accidentially calling wait() instead is a plain error which will result in the application behaving in an unexpected way and possibly becoming vulnurable to an attack. Asynchronous environment is especially vulnurable to such errors as deadlock may occur and ultimately lead to denial-of-service state.<p><b>Example</b><br/>The following code will be marked as a violation because the <code>wait()</code> method used:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void  myFunction( Condition cond )<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cond.wait();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch( InterruptException e){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
