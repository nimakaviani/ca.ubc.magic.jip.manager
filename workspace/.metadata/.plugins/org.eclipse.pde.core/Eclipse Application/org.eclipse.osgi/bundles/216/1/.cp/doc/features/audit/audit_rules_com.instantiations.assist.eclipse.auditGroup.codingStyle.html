<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Coding Style</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Coding Style</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for code that does not fit a specified style of coding.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.accessorUsageInDefiningClass">Accessor Usage in Defining Class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.avoidInstanceInitializers">Avoid Instance Initializers</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidNestedAssignments">Avoid Nested Assignments</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidNestedBlocks">Avoid Nested Blocks</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidPrimitiveMethodParameters">Avoid Primitive Method Parameters</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.badlyLocatedArrayDeclarators">Badly Located Array Declarators</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.breakWithLabel">Break with Label</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.conditionalOperatorUse">Conditional Operator Use</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.constantsInComparison">Constants in Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.continueWithLabel">Continue with Label</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.declareAsInterface">Declare As Interface</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.declareDefaultConstructors">Declare Default Constructors</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.defaultNotLastInSwitch">Default Not Last in Switch</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.defineConstantsInInterfaces">Define Constants in Interfaces</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowArrayInitializers">Disallow Array Initializers</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowDefaultPackage">Disallow Default Package</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.equalityTestWithBooleanLiteral">Equality Test with Boolean Literal</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.explicitThisUsage">Explicit "this" Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.extraSemicolon">Extra Semicolon</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.fullyParenthesizeExpressions">Fully Parenthesize Expressions</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.illegalMainMethod">Illegal Main Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.inappropriateLanguageInJava">Inappropriate Language</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.initializeStaticFields">Initialize Static Fields</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.localDeclaration">Local Declarations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.methodShouldBeStatic">Method Should Be Static</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingBlock">Missing Block</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.multipleReturns">Multiple Return Statements</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.parenthesizeCondition">Parenthesize Condition in Conditional Operator</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.preferredExpression">Preferred Expression</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.codingStyle.returnBooleanExpressionValue">Return Boolean Expression Value</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.staticMemberAccess">Static Member Access</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.typeDeclaration">Type Declarations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.typeMemberOrdering">Type Member Ordering</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryReturnStatementParentheses">Unnecessary Return Statement Parentheses</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useForLoop">Use "for" Loops Instead of "while" Loops</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useCompoundAssignment">Use Compound Assignment</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useEquals">Use equals() Rather Than ==</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useEqualsRatherThanEqualsIgnoreCase">Use equals() Rather Than equalsIgnoreCase()</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.accessorUsageInDefiningClass">Accessor Usage in Defining Class</a></h4><p>
<b>Summary</b><br/>Fields should be referenced directly in their declaring type.<p><b>Description</b><br/>This audit rule finds places in types that declare fields where a declared field could be directly referenced but is instead being indirectly referenced through an accessor method. Such indirect reference is unnecessary and should therefore be avoided.<p><b>Example</b><br/>Given a class that declares the following field and accessor method:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private int itemCount = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public int getItemCount()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return itemCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>The following usage of the accessor method would be flagged as a violation if it occurred within the class:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (getItemCount() &gt; 0) ...</code><p><img src="../../images/auditrules/audit_accessor_usage.gif"></p><h4><a name="com.instantiations.assist.eclipse.analysis.avoidInstanceInitializers">Avoid Instance Initializers</a></h4><p>
<b>Summary</b><br/>Avoid using instance initializers.<p><b>Description</b><br/>Java allows the use of instance initializers to run blocks of code before an object's constructor. However, this is not a well known feature of the Java language, and it may make maintenance harder. Also, there is potential to violate encapsulation. This rule prohibits the use of these instance initializers.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Foo { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidNestedAssignments">Avoid Nested Assignments</a></h4><p>
<b>Summary</b><br/>Assignments should not be nested.<p><b>Description</b><br/>This audit rule finds assignments nested within other assignments.<p><b>Example</b><br/>The assignment to the variable 'i' would be flagged as a violation in the following statement:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int a = (i = j * k) / 2;</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidNestedBlocks">Avoid Nested Blocks</a></h4><p>
<b>Summary</b><br/>Blocks should not be nested.<p><b>Description</b><br/>This audit rule finds blocks nested directly within other blocks.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidPrimitiveMethodParameters">Avoid Primitive Method Parameters</a></h4><p>
<b>Summary</b><br/>Don't use primitive types for method arguments.<p><b>Description</b><br/>Prohibit the use of primitive types in method parameters. All parameters in methods should be Java objects. Exceptions are given to methods that override a superclass method that uses a primitive type as a parameter.<p><b>Example</b><br/>The following method declaration, assuming that it does not override an inherited method, would be flagged as a violation because it has a parameter that is a primitive type:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void setCount(int count)</code><h4><a name="com.instantiations.assist.eclipse.audit.badlyLocatedArrayDeclarators">Badly Located Array Declarators</a></h4><p>
<b>Summary</b><br/>Array declarators should be placed next to the type descriptor of their component type.<p><b>Description</b><br/>This audit rule checks to ensure that the array declarators (the "[]" in the declaration of a variable with an array type) occur after the type name rather than after the variable name.<p><b>Example</b><br/>The following declaration would be flagged as a violation because of the placement of the array brackets:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int x[];</code><p>It should be replaced by a declaration of the form:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int[] x;</code><h4><a name="com.instantiations.assist.eclipse.audit.breakWithLabel">Break with Label</a></h4><p>
<b>Summary</b><br/>Break statements should not reference a labeled statement.<p><b>Description</b><br/>This audit rule finds break statements that reference a labeled statement. The use of a label with a break statement makes the code much harder to read and maintain, and should therefore be avoided. Consider moving the code that contains the break into a separate method and using a return statement instead.<p><b>Example</b><br/>The following break statement would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;outer: for (int i = 0; i &lt; array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; array[i].length; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (array[i][j] == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break outer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.conditionalOperatorUse">Conditional Operator Use</a></h4><p>
<b>Summary</b><br/>The conditional operator should not be used.<p><b>Description</b><br/>This audit rule finds places where the conditional operator (?:) has been used.<p><b>Example</b><br/>The following use of the conditional operator would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;netSales = customerGetsDiscount(grossSales) ? computeDiscount(grossSales) : grossSales;</code><h4><a name="com.instantiations.assist.eclipse.audit.constantsInComparison">Constants in Comparison</a></h4><p>
<b>Summary</b><br/>Constants should appear on the same side in comparisons.<p><b>Description</b><br/>This audit rule looks for comparisons involving exactly one constant value and ensures that the constant appears on the side selected by the user. This is primarily useful to ensure consistency for ease of comprehension. There is some justification for specifying that constants should appear on the left because then the compiler will catch cases where the assignment operator was mistakenly used when a comparison operator was intended.<p><b>Example</b><br/>If the rule has been configured so that constants are required to be on the left hand side, the following comparison would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (count &gt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_constants_in_comparison.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.continueWithLabel">Continue with Label</a></h4><p>
<b>Summary</b><br/>Continue statements should not reference a labeled statement.<p><b>Description</b><br/>This audit rule finds continue statements that reference a labeled statement. The use of a label with a continue statement makes the code much harder to read and maintain, and should therefore be avoided.<p><b>Example</b><br/>The following continue statement would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;outer: for (int i = 0; i &lt; array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; array[i].length; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (array[i][j] == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue outer;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.declareAsInterface">Declare As Interface</a></h4><p>
<b>Summary</b><br/>Variables of certain types should be declared using an interface.<p><b>Description</b><br/>This audit rule finds declarations of fields, local variables, and methods whose type should have been declared to be an interface but was declared to be a class that implements the interface instead. The list of interfaces that are checked can be configured.<p><b>Example</b><br/>If the type java.util.List is on the list of interfaces, the following would be flagged as a violation because the declared type of the field should have been "List":<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private ArrayList myList;</code><p><img src="../../images/auditrules/audit_declare_interface.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.declareDefaultConstructors">Declare Default Constructors</a></h4><p>
<b>Summary</b><br/>Types should declare a default constructor.<p><b>Description</b><br/>This audit rule finds class declarations that do not contain the declaration of a default (zero argument) constructor.<p><b>Example</b><br/>The following class declaration would be flagged as a violation because it does not implement a default constructor:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Employee<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Employee(String name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.defaultNotLastInSwitch">Default Not Last in Switch</a></h4><p>
<b>Summary</b><br/>The default case should be the last case in a switch statement.<p><b>Description</b><br/>This audit rule finds switch statements in which the default case is not the last case. Making the default case always be last improves the readability of the code by making it easier to locate the default behavior.<p><b>Example</b><br/>The following case statement would be flagged as a violation because the default case is not the last case:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;switch (registrationType) {<br>&nbsp;&nbsp;&nbsp;&nbsp;case 0: \ audit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;case 1: \ for credit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;case 2: \ pass/fail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.defineConstantsInInterfaces">Define Constants in Interfaces</a></h4><p>
<b>Summary</b><br/>Constants should be defined in an interface.<p><b>Description</b><br/>This audit rule checks for constants (public static final fields) that are declared in a class. Such fields should be declared in an interface so that they are easier to share and can be referenced without introducing extra coupling.<p><b>Example</b><br/>The following field declaration would be flagged if it occurred outside of an interface:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public static final int DAYS_IN_WEEK = 7;</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowArrayInitializers">Disallow Array Initializers</a></h4><p>
<b>Summary</b><br/>Arrays should not be statically initialized by an array initializer.<p><b>Description</b><br/>This audit rule checks for array variables that are initialized (either in the initializer or in an assignment statement) using an array initializer.<p><b>Example</b><br/>The following array declaration would be flagged because of the use of an array initializer:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int[] values = {0, 1, 2};</code><h4><a name="com.instantiations.assist.eclipse.audit.disallowDefaultPackage">Disallow Default Package</a></h4><p>
<b>Summary</b><br/>Code should not be defined in the default package.<p><b>Description</b><br/>This audit rule looks for compilation units that are declared in the default package. All code should be structured into packages.<h4><a name="com.instantiations.assist.eclipse.audit.equalityTestWithBooleanLiteral">Equality Test with Boolean Literal</a></h4><p>
<b>Summary</b><br/>Boolean literals should never be used in equality tests.<p><b>Description</b><br/>This audit rule finds equality tests (using either == or !=) in which either or both of the operands are a Boolean literal (either true or false).<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (todayIsTuesday() == true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.explicitThisUsage">Explicit "this" Usage</a></h4><p>
<b>Summary</b><br/>Instance fields should, or should not, be accessed using "this".<p><b>Description</b><br/>This audit rule checks for the explicit usage of the keyword "this" when accessing instance fields. The rule can be configured to always check for the presence or absence of the keyword.<p><b>Example</b><br/>If the rule is configured to disallow using "this" to qualify fields unless necessary, the following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void incrementCount(int amount)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.count += amount;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_explicit_this_usage.gif" width="242" height="62"></p><h4><a name="com.instantiations.assist.eclipse.audit.extraSemicolon">Extra Semicolon</a></h4><p>
<b>Summary</b><br/>Extra semicolons clutter the code and serve no useful purpose.<p><b>Description</b><br/>This audit rule finds places where a semicolon occurs but is not needed. While not strictly an error, such semicolons clutter the code and serve no useful purpose.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;while (index &lt; count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = index + 1;;<br>&nbsp;&nbsp;&nbsp;&nbsp;};</code><h4><a name="com.instantiations.assist.eclipse.audit.fullyParenthesizeExpressions">Fully Parenthesize Expressions</a></h4><p>
<b>Summary</b><br/>All nested expressions should be fully parenthesized.<p><b>Description</b><br/>This audit rule checks for nested binary expressions that are not fully parenthesized and flags them.<p><b>Example</b><br/>The two multiplication expressions in the statement below should each be parenthesized to make clear the order of precedence:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;result = x * x + y * y;</code><h4><a name="com.instantiations.assist.eclipse.audit.illegalMainMethod">Illegal Main Method</a></h4><p>
<b>Summary</b><br/>A main method should only be declared in application classes.<p><b>Description</b><br/>This audit rule checks for declarations of a main method occurring in non-application classes. This is most commonly done in order to write testing code, but testing code should be written in a test case.<p><img src="../../images/auditrules/audit_illegal_mail_method.gif" width="374" height="81"></p><h4><a name="com.instantiations.assist.eclipse.audit.inappropriateLanguageInJava">Inappropriate Language</a></h4><p>
<b>Summary</b><br/>Inappropriate language should not be used in the source code.<p><b>Description</b><br/>This audit rule finds uses of inappropriate language within the source code.<p><img src="../../images/auditrules/audit_inappropriate_language.gif" width="374" height="169"></p><h4><a name="com.instantiations.assist.eclipse.audit.initializeStaticFields">Initialize Static Fields</a></h4><p>
<b>Summary</b><br/>All static fields should be initialized.<p><b>Description</b><br/>This audit rule looks for static fields that are not initialized. A static field can be initialized either as part of its declaration or in a static initializer.<p><b>Example</b><br/>Assuming that there are no static initializers in the class containing the following static field declaration, it would be flagged because the field is not initialized:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private static HashMap instanceMap;</code><h4><a name="com.instantiations.assist.eclipse.audit.localDeclaration">Local Declarations</a></h4><p>
<b>Summary</b><br/>Verification that local variable declarations follow a specified style of coding.<p><b>Description</b><br/>This audit rule finds source in which local variable declarations do not follow a specified style of coding. This includes the order of local variables defined in a block of code, whether or not each variable is explicitly initialized, and whether or not each variable is declared in a separate statement.<p><b>Example</b><br/>If the rule is configured to require that local variables be declared at the beginning of the method, then the following variable declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object object)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(object instanceof OrderedSet)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int thisSize = getSize();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_local_declarations.gif" width="273" height="84"></p><h4><a name="com.instantiations.assist.eclipse.audit.methodShouldBeStatic">Method Should Be Static</a></h4><p>
<b>Summary</b><br/>Methods that do not access any instance state or instance methods should be static.<p><b>Description</b><br/>This audit rule checks for methods that do not access any instance state or instance methods. Such methods should be made static. Note, however, that this method does not find methods that only call instance methods that should also be static, so changing some of the methods to static methods might cause additional methods to then be flagged.<p><b>Example</b><br/>The following method would be flagged as a violation because it does not reference any instance specific state:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int getDefaultSize()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 256;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_method_should_be_static.gif" width="373" height="79"></p><h4><a name="com.instantiations.assist.eclipse.audit.missingBlock">Missing Block</a></h4><p>
<b>Summary</b><br/>A single statement should never be used where a block is allowed.<p><b>Description</b><br/>This audit rule checks for statements that control the execution of another statement (do, for, if or while) to ensure that the statement being controlled is always a block.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (color == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color = getDefaultColor();</code><p><img src="../../images/auditrules/audit_missing_block.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.multipleReturns">Multiple Return Statements</a></h4><p>
<b>Summary</b><br/>Methods should have a single return statement.<p><b>Description</b><br/>This audit rule looks for methods that contain multiple return statements (or constructors or void methods that contain any return statements). Such methods are generally too complex and need to be rewritten or refactored in order to make their logic easier to understand.<p><b>Example</b><br/>The following method would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int returnCode(String str)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ("ABC".equals(str)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ("123".equals(str)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.parenthesizeCondition">Parenthesize Condition in Conditional Operator</a></h4><p>
<b>Summary</b><br/>The condition in a conditional operator should be parenthesized if it contains a binary operator.<p><b>Description</b><br/>This audit rule looks for uses of the conditional operator in which the condition contains a binary operator but has not been parenthesized.<p><b>Example</b><br/>The following expression would be flagged as a violation because the condition is not parenthesized:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;childCount = children == null ? 0 : children.size();</code><h4><a name="com.instantiations.assist.eclipse.audit.preferredExpression">Preferred Expression</a></h4><p>
<b>Summary</b><br/>Some expressions are preferred over other equivalent expressions.<p><b>Description</b><br/>This audit rule searches for expressions that can be replaced with other equivalent and more preferred expressions. Specifically Colors can be replaced with Color constants and Booleans with Boolean constants.<p><b>Example</b><br/>The expression<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Color(0, 0, 0)</code><p>can be replaced by<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Color.black</code><p>and the expression<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Boolean(true)</code><p>can be replaced by<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Boolean.TRUE</code><p><img src="../../images/auditrules/audit_preferred_expression.gif"></p><h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.codingStyle.returnBooleanExpressionValue">Return Boolean Expression Value</a></h4><p>
<b>Summary</b><br/>Return the value of a boolean expression directly.<p><b>Description</b><br/>Rather than testing a boolean value in an if-statement then returning true or false, simply return the value of the boolean expression directly.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;if (booleanValue)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</code><p>Should be changed to:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;return booleanValue;</code><h4><a name="com.instantiations.assist.eclipse.audit.staticMemberAccess">Static Member Access</a></h4><p>
<b>Summary</b><br/>Static members should only be accessed by referencing the type in which they are declared.<p><b>Description</b><br/>This audit rule looks for references to static members that use either a subtype of the type in which they are declared or an instance of either the declaring type or one of its subtypes.<p><b>Example</b><br/>Given the following declarations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class DeclaringClass<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static final int ZERO = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public class SubclassOfDeclaringClass extends DeclaringClass<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;DeclaringClass instanceOfDeclaringClass;<br>&nbsp;&nbsp;&nbsp;&nbsp;SubclassOfDeclaringClass instanceOfSubclass;</code><p>The following expressions would all be flagged as violations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;SubclassOfDeclaringClass.ZERO<br>&nbsp;&nbsp;&nbsp;&nbsp;instanceOfDeclaringClass.ZERO<br>&nbsp;&nbsp;&nbsp;&nbsp;instanceOfSubclass.ZERO</code><h4><a name="com.instantiations.assist.eclipse.audit.typeDeclaration">Type Declarations</a></h4><p>
<b>Summary</b><br/>Verification that type declarations follow a specified style of coding.<p><b>Description</b><br/>This audit rule finds source in which type declarations do not follow a specified style of coding. One example is that the first type declaration in a file should be a one with a name matching that of the file if such a type is defined in the file.<h4><a name="com.instantiations.assist.eclipse.audit.typeMemberOrdering">Type Member Ordering</a></h4><p>
<b>Summary</b><br/>Verification that type members follow a specified order.<p><b>Description</b><br/>This audit rule is used to check the order of members within a type. Simple rules include checking that main() is last and that members with a common name are grouped together. More complex orderings are specified with the Global Ordering check box. When the global ordering check box is checked you can choose one of the orderings from the list:<p>Alphabetical - all members should be arranged alphabetically by name with no regard for member type or modifiers. Initializers have no names and can appear anywhere.<p>Fields First - members should appear in the order: fields, initializers, constructors, methods, inner types. Within those groups they should be arranged alphabetically.<p>Constructors First - members should appear in the order: constructors, fields, initializers, methods, inner types. Within those groups they should be arranged alphabetically.<p>Public to Private - members should appear in the modifier order: public, protected, private. Within those groups they should be arranged alphabetically.<p>Private to Public - members should appear in the order: private, protected, public. Within those groups they should be arranged alphabetically.<p>The above choices are followed by combinations. "Fields First/Public to Private", for example, means that members should be arranged in Fields First order, be arranged in Public to Private order within those groups, then alphabetically. The other combinations follow suit.<p><img src="../../images/auditrules/audit_type_member_ordering.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryReturnStatementParentheses">Unnecessary Return Statement Parentheses</a></h4><p>
<b>Summary</b><br/>The expression in a return statement should not be parenthesized.<p><b>Description</b><br/>This audit rule looks for return statements where the expression that computes the value to be returned is enclosed in parentheses. They are unnecessary and typically make the code harder to read and maintain.<p><b>Example</b><br/>The following return statement's expression would be flagged as a violation because the parentheses are not necessary:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;return (x * x);</code><h4><a name="com.instantiations.assist.eclipse.audit.useForLoop">Use "for" Loops Instead of "while" Loops</a></h4><p>
<b>Summary</b><br/>Disallows the use of "while" loops.<p><b>Description</b><br/>This audit rule checks for the use of "while" loops rather than "for" loops. "for" loops allow loop-scoped variables to be declared during loop setup, minimizing the scope of loop-control variables to just the body of the loop. Since their scope ends after the loop, they cannot be referenced later accidentally.<p><b>Example</b><br/>The following while loop would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int index = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;while (index &lt; array.length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>because it should be rewritten as:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_use_for_loops.gif" width="228" height="22"></p><h4><a name="com.instantiations.assist.eclipse.audit.useCompoundAssignment">Use Compound Assignment</a></h4><p>
<b>Summary</b><br/>Compound assignment statements are more compact and hence make the code easier to read.<p><b>Description</b><br/>This audit rule looks for simple assignment statements that could be converted into compound assignment statements.<p><b>Example</b><br/>The following assignment would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;sum = sum + array[i];</code><p>because it could be more compactly written as:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;sum += array[i];</code><h4><a name="com.instantiations.assist.eclipse.audit.useEquals">Use equals() Rather Than ==</a></h4><p>
<b>Summary</b><br/>Values should not be compared using equals (==) or not equals (!=).<p><b>Description</b><br/>This audit rule finds places where two values are compared using either the equals (==) or not equals (!=) operators.<p><b>Example</b><br/>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (firstString == secondString) {</code><p>because it should be rewritten as:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (firstString.equals(secondString)) {</code><h4><a name="com.instantiations.assist.eclipse.audit.useEqualsRatherThanEqualsIgnoreCase">Use equals() Rather Than equalsIgnoreCase()</a></h4><p>
<b>Summary</b><br/>Use String.equals() rather than String.equalsIgnoreCase() to compare strings.<p><b>Description</b><br/>The method String.equals() should be used rather than the method String.equalsIgnoreCase() to compare strings.<p><b>Example</b><br/>The following use of the method equalsIgnoreCase() would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (command.equalsIgnoreCase("delete")) {</code></body>
</html>
