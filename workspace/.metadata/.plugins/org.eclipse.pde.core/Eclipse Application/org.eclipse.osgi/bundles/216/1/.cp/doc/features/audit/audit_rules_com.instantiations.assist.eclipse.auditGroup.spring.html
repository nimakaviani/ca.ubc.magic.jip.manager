<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Spring</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Spring</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for code that violates the best practices specified for programs using the Spring framework.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.spring.avoidAccessingFactoryBeanDirectly">Avoid Accessing the FactoryBean Directly</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.avoidUsingAutowiring">Avoid Using Autowiring</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.declareSettersForBeansFields">Declare Setters for Bean Fields</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.dontUseDefaultBeanNames">Don't Use Default Bean Names</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.implementBeanNameAwareInterface">Implement BeanNameAware Interface</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.missingApplicationContextFile">Missing Application Context File</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.missingBeanDescription">Missing Bean Description</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.propertyFileMustExists">Property File Must Exist</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.referencedClassNotDefined">Referenced Class Not Defined</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.undefinedPlaceholder">Undefined Placeholder</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useAdditionalAttribute">Use Additional Attribute in <constructor-arg> Tag</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useApplicationContextToAssembleBeans">Use ApplicationContext to Assemble Beans</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useIdrefElement">Use idref Element</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useSetterInjection">Use Setter Injection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useTypeForConstructorArgumentMatching">Use Type for Constructor Argument Matching</a></li>
      <li><a href="#com.instantiations.assist.eclipse.spring.useXmlBeanFactory">Use XmlBeanFactory</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.spring.avoidAccessingFactoryBeanDirectly">Avoid Accessing the FactoryBean Directly</a></h4><p>
<b>Summary</b><br/>Avoid accessing the FactoryBean directly and invoking getObject() manually.<p><b>Description</b><br/>This audit rule looks for places where a FactoryBean is accessed directly. Accessing the FactoryBean directly is actually very simple: you simply prefix the bean name with an ampersand in the call to getBean(). This feature is used in a few places in the Spring code, but your application should really have no reason to use it. The FactoryBean interface is intended to be used as a piece of supporting infrastructure to allow you to use more of your application's classes in an IoC setting. Avoid accessing the FactoryBean directly and invoking getObject() manually; if you do not, you are making extra work for yourself and are unnecessarily coupling your application to a specific implementation detail that could quite easily change in the future.<p><b>Example</b><br/>The invocation factory.getBean("&amp;shaDigest") in the following code would be flagged because it uses direct access to a FactoryBean:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class AccessingFactoryBeans {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeanFactory factory = new XmlBeanFactory(new FileSystemResource("..."));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageDigest digest = (MessageDigest) factory.getBean("shaDigest");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageDigestFactoryBean factoryBean = <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MessageDigestFactoryBean) factory.getBean("&amp;shaDigest");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.spring.avoidUsingAutowiring">Avoid Using Autowiring</a></h4><p>
<b>Summary</b><br/>Avoid using autowiring of dependencies through introspection of the bean classes.<p><b>Description</b><br/>This audit rule looks for places where dependencies are being autowired. Spring can autowire dependencies through introspection of the bean classes so that you do not have to explicitly specify the bean properties or constructor arguments. Bean properties can be autowired either by property names or matching types. Constructor arguments can be autowired by matching types. Autowiring can potentially save some typing and reduce clutter.<p>However, you should not use it in real-world projects because it sacrifices the explicitness and maintainability of the configurations. Autowiring seems like a good idea to make the XML configuration file smaller, but this will actually increase the complexity down the road, especially when you are working on a large project where many beans are defined. Spring allows you to mix autowiring and explicit wiring, but the inconsistency will make the XML configurations even more confusing.<p><b>Example</b><br/>The following bean declaration would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="orderService"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.test.spring.OrderService"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autowire="byName"/&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.declareSettersForBeansFields">Declare Setters for Bean Fields</a></h4><p>
<b>Summary</b><br/>Declare setter methods for all fields of bean class.<p><b>Description</b><br/>This audit rule looks for fields declared in beans for which no setter methods are declared. Setter injection is the preferred type of dependency injection in Spring. Setter injection is more flexible and manageable. Your bean classes should have setters for all fields to use this technique.<p><b>Example</b><br/>The field "text" would be flagged because it does not have a setter method:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Bean {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getText() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.spring.dontUseDefaultBeanNames">Don't Use Default Bean Names</a></h4><p>
<b>Summary</b><br/>Specify id as the bean identifier.<p><b>Description</b><br/>This audit rule looks for places where the bean name is not explicitly given. If you give the <bean> tag an id attribute, then the value of that attribute is used as the name. If no id attribute is specified, Spring looks for a name attribute and, if one is defined, it uses the first name defined in the name attribute. (We say the first name because it is possible to define multiple names within the name attribute.) If neither the id nor the name attribute is specified, Spring uses the bean's class name as the name, provided, of course, that no other bean is using the same name.<p>Avoid using the automatic name by class behavior. This doesn't allow you much flexibility to define multiple beans of the same type, and it is much better to define your own names. That way, if Spring changes the default behavior in the future, your application will continue to work.<p>You can specify either an id or name as the bean identifier. Using ids will not increase readability, but it can leverage the XML parser to validate the bean references.<p>When choosing whether to use id or name, always use id to specify the bean's default name. The only drawback of using the id attribute is that you are limited to characters that are allowed within XML element IDs. If you find that you cannot use a character you want in your name, then you can specify that name using the name attribute, which does not have to adhere to the XML naming rules.<p><b>Example</b><br/>Don't use<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean name="string2" class="java.lang.String"/&gt;</code><p>or<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean class="java.lang.String"/&gt;</code><p>Always use the following instead<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="string1" class="java.lang.String"/&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.implementBeanNameAwareInterface">Implement BeanNameAware Interface</a></h4><p>
<b>Summary</b><br/>Implement the BeanNameAware interface in your bean classes.<p><b>Description</b><br/>This audit rule looks for beans that do not implement the BeanNameAware interface. Being able to have a bean find out its name at runtime is really useful for logging. Consider a situation where you have many beans of the same type running under different configurations. The bean name can be included in log messages to help you differentiate between which one is generating errors and which ones are working fine when something goes wrong.<p>Implementation is fairly trivial and no special configuration is required to take advantage of the BeanNameAware interface.<p><b>Example</b><br/>Implementation looks like following:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class LoggingBean implements BeanNameAware {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String beanName = null;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setBeanName(String beanName) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.beanName = beanName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.spring.missingApplicationContextFile">Missing Application Context File</a></h4><p>
<b>Summary</b><br/>XML files referenced in 'contextConfigLocation' attribute of &lt;context-param&gt; section in web.xml configuration file should exist.<p><b>Description</b><br/>This audit rule looks for references to application context configuration files that do not exist. The application context configuration files are referenced in the contextConfigLocation attribute of a &lt;context-param&gt; section in the web.xml configuration file.<p><b>Example</b><br/>Given the following content in a web.xml file:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;context-param&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param-value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/WEB-INF/dataAccessContext.xml<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/WEB-INF/applicationContext.xml<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/param-value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/context-param&gt;</code><p>The file /WEB-INF/dataAccessContext.xml would be flagged if the file does not exist, as would the file /WEB-INF/applicationContext.xml.<h4><a name="com.instantiations.assist.eclipse.spring.missingBeanDescription">Missing Bean Description</a></h4><p>
<b>Summary</b><br/>Every bean declaration should have a description.<p><b>Description</b><br/>This audit rule looks for bean declarations that do not include a description. The advantage of using the description element is that it is easy for tools to pick up the description from this element.<p><b>Example</b><br/>Bean declarations will be flagged unless they contain a description element such as the following:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;beans&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/description&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/beans&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.propertyFileMustExists">Property File Must Exist</a></h4><p>
<b>Summary</b><br/>Property file referenced for the placeholder configurer bean must exists.<p><b>Description</b><br/>If a bean uses one of the following classes:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer<br>&nbsp;&nbsp;&nbsp;&nbsp;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer<br>&nbsp;&nbsp;&nbsp;&nbsp;org.springframework.web.context.support.ServletContextPropertyPlaceholderConfigurer</code><p>this audit rule checks for a 'location' property and the existence of the property file referenced in this property.<p><b>Example</b><br/>The file name jdbc.properties would be flagged if the file jdbc.properties does not exist:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="propertyConfigurer"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="location"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>jdbc.properties&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.referencedClassNotDefined">Referenced Class Not Defined</a></h4><p>
<b>Summary</b><br/>Classes referenced in Spring configuration files should be declared.<p><b>Description</b><br/>This audit rule checks for references within a configuration file to classes that are not declared in the associated project. Either the references should be removed or the classes should be declared.<p><b>Example</b><br/>In the following entry (from a XML configuration file), the value of the "class" attribute would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id="test"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="class.not.exists/"&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.undefinedPlaceholder">Undefined Placeholder</a></h4><p>
<b>Summary</b><br/>All properties used in placeholders should be defined in the property file.<p><b>Description</b><br/>This audit rule looks for properties used in placeholders that are not defined in the associated property file.<p><b>Example</b><br/>The string jdbc.missed would be flagged if "jdbc.missed" doesn't exist in the property file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="propertyConfigurer"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="location"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;/WEB-INF/jdbc.properties&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="dataSource"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="org.springframework.jdbc.datasource.DriverManagerDataSource"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="driverClassName"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>${jdbc.driver}&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="url"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>${jdbc.url}&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="username"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>${jdbc.user}&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="missed"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>${jdbc.missed}&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.useAdditionalAttribute">Use Additional Attribute in <constructor-arg> Tag</a></h4><p>
<b>Summary</b><br/>Use an additional attribute in the &lt;constructor-arg&gt; tag in your configuration file.<p><b>Description</b><br/>When you have more than one constructor argument or your class has more than one constructor you should specify an additional attribute (index or type, prefer type) in the &lt;constructor-arg&gt; tag. This audit rule looks for tags that need an additional argument but do not have one.<p><b>Example</b><br/>If you have following class:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class ConstructorConfusion {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String someValue;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ConstructorConfusion(String someValue) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.someValue = someValue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ConstructorConfusion(int someValue) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.someValue = "Number: " + Integer.toString(someValue);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>then the following &lt;constructor-arg&gt; tag would be flagged because the class has more than one constructor<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="constructorConfusion"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.test.spring.ConstructorConfusion"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;90&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.useApplicationContextToAssembleBeans">Use ApplicationContext to Assemble Beans</a></h4><p>
<b>Summary</b><br/>Use the ApplicationContext, rather than imports, to assemble beans.<p><b>Description</b><br/>This audit rule looks for places where imports are used to assemble beans. Like imports in Ant scripts, Spring import elements are useful for assembling modularized bean definitions. However, instead of pre-assembling them in the XML configurations using imports, it is more flexible to configure them through the ApplicationContext. Using the ApplicationContext also makes the XML configurations easier to manage.<p><b>Example</b><br/>Given the following bean declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;beans&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;import resource="billingServices.xml"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;import resource="orderServices.xml"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;import resource="shippingServices.xml"/&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="orderService"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.test.spring.OrderService"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;beans&gt;</code><p>the import lines would be flagged.<p>You can pass an array of bean definitions to the ApplicationContext constructor as follows:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;String[] serviceResources = { "orderServices.xml",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"billingServices.xml", "shippingServices.xml" };<br>&nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext orderServiceContext = new ClassPathXmlApplicationContext(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serviceResources);</code><h4><a name="com.instantiations.assist.eclipse.spring.useIdrefElement">Use idref Element</a></h4><p>
<b>Summary</b><br/>Use the idref element to pass the id of another bean in the container.<p><b>Description</b><br/>The idref element is an error-proof way to pass the id of another bean in the container (to a &lt;constructor-arg/&gt; or &lt;property/&gt; element):<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="theTargetBean" class="..."/&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="theClientBean" class="..."&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="targetName"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;idref bean="theTargetBean"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><p>The above bean definition snippet is exactly equivalent (at runtime) to the following snippet:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="theTargetBean" class="..."/&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="client" class="..."&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="targetName"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;theTargetBean&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><p>The main reason the first form is preferable to the second is that using the idref tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the 'targetName' property of the 'client' bean. Any typo will only be discovered (with most likely fatal results) when the 'client' bean is actually instantiated. If the 'client' bean is a prototype bean, this typo (and the resulting exception) might only be discovered long after the container is actually deployed.<p><b>Example</b><br/>The &lt;value&gt; tag in the following bean declaration would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="client" class="..."&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="targetName"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value>theTargetBean&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;<br></code><h4><a name="com.instantiations.assist.eclipse.spring.useSetterInjection">Use Setter Injection</a></h4><p>
<b>Summary</b><br/>Use setter injection rather than constructor injection.<p><b>Description</b><br/>This audit rule looks for beans that use constructor injection when they could be using setter injection. Spring provides three types of dependency injection: constructor injection, setter injection, and method injection. Typically we only use the first two types. Constructor injection can ensure that a bean cannot be constructed in an invalid state, but setter injection is more flexible and manageable, especially when the class has multiple properties and some of them are optional.<p><b>Example</b><br/>The following bean declaration would be flagged because it uses constructor injection:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="orderService"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.test.spring.OrderService"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg ref="orderDAO"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><p>it should be changed to:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean id="orderService"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.test.spring.OrderService"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="orderDAO" ref="orderDAO"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.useTypeForConstructorArgumentMatching">Use Type for Constructor Argument Matching</a></h4><p>
<b>Summary</b><br/>Use the type attribute, rather than the index attribute, for constructor argument matching.<p><b>Description</b><br/>Spring allows you to use a zero-based index to solve the ambiguity problem when a constructor has more than one arguments of the same type, or when value tags are used. Using an index is somewhat less verbose, but it is more error-prone and hard to read compared to using the type attribute. You should only use the index attribute when there is an ambiguity problem in the constructor arguments.<p><b>Example</b><br/>For example, instead of using the index attribute as in the following:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean name="billingService" class="example.test.BillingService"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg index="0"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;90&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><p>it is better to use the type attribute like this:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean name="billingService" class="example.test.BillingService"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;constructor-arg type="int"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;90&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</code><h4><a name="com.instantiations.assist.eclipse.spring.useXmlBeanFactory">Use XmlBeanFactory</a></h4><p>
<b>Summary</b><br/>Use the XML configuration format of BeanDefinition information for all but the most trivial of applications.<p><b>Description</b><br/>Spring provides two main BeanFactory implementations. The first, DefaultListableBeanFactory, reads the BeanDefinition information from a property file using the PropertiesBeanDefinitionReader.<p>The second, XmlBeanFactory, allows you to manage your bean configuration using XML rather than properties. Although properties are ideal for small, simple applications, they can quickly become cumbersome when you are dealing with a large number of beans. For this reason, it is preferable to use the XML configuration format for all but the most trivial of applications. The XmlBeanFactory is derived from DefaultListableBeanFactory and simply extends it to perform automatic configuration using the XmlBeanDefinitionReader.<p><b>Example</b><br/>The following main method would be flagged because of its use of DefaultListableBeanFactory:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class PropertiesConfig {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropertiesBeanDefinitionReader rdr = new PropertiesBeanDefinitionReader(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties props = new Properties();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;props.load(new FileInputStream("..."));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdr.registerBeanDefinitions(props);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>you should do this instead:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class XmlConfig {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("..."));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
