<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Performance</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Performance</font></b></h1>
<b>Description</b><br/>This group contains audit rules that report coding practices that can sometimes cause performance problems. These rules will not find every source of performance problems, nor will everything found by these rules be the cause of a performance problem. The use of these rules is in no way a substitute for the use of a good performance profiling tool, but they can be used to promote programming practices that minimize performance problems.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.anonymousClassInLoop">Anonymous Class in Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.appendString">Append String</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidInstantiationInLoops">Avoid Instantiation in Loops</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidInstantiationToGetClass">Avoid Instantiation to Get Class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidNoArgStringConstructor">Avoid the no-argument String constructor</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowInstanceof">Avoid Using "instanceof"</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.bewareOfURLEqualsAndHashCode">Beware of URL equals() and hashCode()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.classGetNameUsage">Class getName() Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.concatenationInAppend">Concatenation In Appending Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.debuggingCode">Debugging Code</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.defineInitialCapacity">Define Initial Capacity</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.defineLoadFactor">Define Load Factor</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.detectMultipleIterations">Detect Multiple Iterations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.doNotCreateFinalizableObjects">Do Not Create Finalizable Objects</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.performance.doNotUseConcatenationToConvertToString">Don't use concatenation to convert to String</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.efficientExpression">Efficient Expression</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.emptyStringDetection">Empty String Detection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.indexArraysWithInts">Index Arrays with Ints</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.inefficientUseOfToArray">Inefficient use of toArray()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.invokeSynchronizedMethodInLoop">Invoke Synchronized Method In Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.largeNumberOfSwitchStatementCases">Large Number of Switch Statement Cases</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.methodInvocationInLoopCondition">Method Invocation in Loop Condition</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.multiplicationOrDivisionByPowersOf2">Multiplication Or Division By Powers of 2</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.precomputeConstantCalculations">Pre-compute Constant Calculations</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.reflectionMethodUsage">Reflection Method Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.replaceSynchronizedClasses">Replace Synchronized Classes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.reusableImmutables">Reusable Immutables</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.runtimeMethodUsage">Runtime Method Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.staticInstantiation">Static Instantiation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.stringConcatenationInLoop">String Concatenation in Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.stringCreatedFromLiteral">String Created from Literal</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.synchronizedInLoop">Synchronized In Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.temporaryObjectCreation">Temporary Object Creation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.unnecessaryToString">Unnecessary toString() Method Invocation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryCast">Unnecessary Type Cast</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useArraycopyRatherThanALoop">Use arraycopy() Rather Than a Loop</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useAvailableConstants">Use Available Constants</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useBufferedIO">Use Buffered IO</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useCharRatherThanString">Use char Rather Than String</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useCharAtRatherThanStartsWith">Use charAt() Rather Than startsWith()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useStringBufferLength">Use StringBuffer length()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.performance.useValueOf">Use valueOf() to wrap primitives</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.variableDeclaredInLoop">Variable Declared Within a Loop</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.anonymousClassInLoop">Anonymous Class in Loop</a></h4><p>
<b>Summary</b><br/>Placing an anonymous class inside a loop can decrease performance.<p><b>Description</b><br/>Placing the creation of an instance of an anonymous class inside a loop will create a new instance each time the loop body is executed. Because the state of the object cannot depend on the state of any variables that change within the loop, a single object can usually be created outside the loop, increasing performance.<p><b>Example</b><br/>In the following code:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;EventGenerator[] generators;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; generators.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generators[i].addListener(new Listener() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void eventGenerated()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>The creation of the listener could, and should, be moved outside the loop because a single listener could easily be shared by all of the event generators.<h4><a name="com.instantiations.assist.eclipse.audit.appendString">Append String</a></h4><p>
<b>Summary</b><br/>Appending strings with single characters to buffers or streams is slower than appending just the single character.<p><b>Description</b><br/>This audit rule finds single character string literals as a single argument to a method invocation where that argument can be replaced by a character literal to improve performance.<p><b>Example</b><br/>Given the following declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sb = new StringBuffer();</code><p>The statement<p><code>&nbsp;&nbsp;&nbsp;&nbsp;sb.append("a");</code><p>would be flagged as needing to be replaced by the statement<p><code>&nbsp;&nbsp;&nbsp;&nbsp;sb.append('a');</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidInstantiationInLoops">Avoid Instantiation in Loops</a></h4><p>
<b>Summary</b><br/>Avoid instantiating classes in loops.<p><b>Description</b><br/>Instantiation of a class requires memory allocation. If a class is instantiated within a loop, memory allocation will be performed over and over again. If the objects are kept, this will eat up memory; if they are abandoned, it will cause excessive garbage collection.<br>However, this rule allows instantiation in return statements and throw statements, since they will not be repeated. It also allows instantiation in catch blocks, since these should not be reached regularly.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;while (a &lt; b) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String s = new String();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidInstantiationToGetClass">Avoid Instantiation to Get Class</a></h4><p>
<b>Summary</b><br/>Avoid instantiating an object just to call <code>getClass()</code>.<p><b>Description</b><br/>It is unnecessary to create a new instance of a class just to call its <code>getClass()</code> method. The public member <code>class</code> can be accessed without instantiation.<p><b>Example</b><br/>The following would be flagged as a violation, since <code>Object.class</code> would be more efficient:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Object().getClass(); </code><h4><a name="com.instantiations.assist.eclipse.audit.avoidNoArgStringConstructor">Avoid the no-argument String constructor</a></h4><p>
<b>Summary</b><br/>Avoid using the no-argument String constructor.<p><b>Description</b><br/>The no-argument String constructor <code>new String()</code>, creates a String that will not be functionally different from the empty String (<code>""</code>). Since Java guarantees that identical String constants will all be the same instance, you can improve performance by using the empty String instead.<p><b>Example</b><br/>The following would be flagged as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;String foo = new String();<br></code><p>This could be replaced with the following, which would conserve memory: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;String foo = "";<br></code><h4><a name="com.instantiations.assist.eclipse.audit.disallowInstanceof">Avoid Using "instanceof"</a></h4><p>
<b>Summary</b><br/>Use polymorphism instead of instanceof (except when used with interfaces).<p><b>Description</b><br/>This audit rule looks for uses of "instanceof". In general, one should use polymorphism instead of instanceof. Optionally, require that "instanceof" only be used on interfaces.<p><b>Example</b><br/>The following uses of the instanceof operator would be flagged as violations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (employee instanceof AccountingEmployee) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Accounting";<br>&nbsp;&nbsp;&nbsp;&nbsp;} else if (employee instanceof DevelopmentEmployee) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Development";<br>&nbsp;&nbsp;&nbsp;&nbsp;...</code><p><img src="../../images/auditrules/audit_avoid_instanceof.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.bewareOfURLEqualsAndHashCode">Beware of URL equals() and hashCode()</a></h4><p>
<b>Summary</b><br/>Be careful when and how you use the <code>equals()</code> and <code>hashCode()</code> methods of the <code>URL</code> class.<p><b>Description</b><br/>Both the <code>equals()</code> and <code>hashCode()</code> methods of the <code>URL</code> class resolve the domain name using the Internet. This operation can cause unexpected performance problems. Also, the <code>hashCode()</code> method takes the resolved IP address into account when generating the hash code. This can cause serious problems since many web sites use dynamic DNS. It is possible to store a <code>URL</code> in a hashed collection, and later be unable to retrieve it if the <code>URL</code> resolves to a different IP address.<p>Because of these implementation problems, it is a good idea to convert <code>URL</code>s to <code>URI</code>s before storing them in collections, or using their <code>equals()</code> or <code>hashCode()</code> methods. This can be done easily using <code>URL</code>'s <code>toURI()</code> method, and reversed using <code>URI</code>'s <code>toURL()</code> method.<p>This rule finds places where <code>equals()</code> or <code>hashCode()</code> are explicitly invoked on <code>URL</code> objects and places where URL objects are used in hashed Collections classes. <p><b>Example</b><br/>The following would be flagged as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;URL aUrl = new URL("http://address.com");<br>&nbsp;&nbsp;&nbsp;&nbsp;Set aSet = new HashSet();<br>&nbsp;&nbsp;&nbsp;&nbsp;aSet.add(aUrl);</code><h4><a name="com.instantiations.assist.eclipse.analysis.classGetNameUsage">Class getName() Usage</a></h4><p>
<b>Summary</b><br/>Don't use the Class getName() method.<p><b>Description</b><br/>Don't use the Class getName() method to compare classes.<p><b>Example</b><br/>The following invocation of getName() would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (object.getClass().getName().equals("java.util.ArrayList")) {</code><h4><a name="com.instantiations.assist.eclipse.audit.concatenationInAppend">Concatenation In Appending Method</a></h4><p>
<b>Summary</b><br/>The argument to methods that append to buffers and streams.<p><b>Description</b><br/>This audit rule finds places where the argument to a method that appends to a buffer or stream is the result of a concatenation. In such cases, a separate StringBuffer is being allocated to implement the concatenation, resulting an unnecessary overhead. The items that are being concatenated should be appended separately.<p><b>Example</b><br/>The following invocation of the append method would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;buffer.append("Hello " + userName + "!");</code><h4><a name="com.instantiations.assist.eclipse.audit.debuggingCode">Debugging Code</a></h4><p>
<b>Summary</b><br/>Debugging and profiling code should not be left in production code.<p><b>Description</b><br/>This audit rule finds places in the code where text is being written to either System.out or System.err, or where the methods Throwable.printStackTrace(), Thread.dumpStack(), Runtime.freeMemory(), Runtime.totalMemory(), Runtime.traceMethodCalls() or Runtime.traceInstructions() are being invoked.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("Unexpected exception:");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exception.printStackTrace();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.defineInitialCapacity">Define Initial Capacity</a></h4><p>
<b>Summary</b><br/>Define an initial capacity for ArrayList, HashMap, HashSet, Hashtable, StringBuffer, StringBuilder, WeakHashMap, or  Vector instances.<p><b>Description</b><br/>This audit rule requires an initial capacity to be specified when creating instances of ArrayList, HashMap, HashSet, Hashtable, StringBuffer, StringBuilder, WeakHashMap, or  Vector. Array capacity expansion involves allocating a larger array and copying the contents of the old array to a new one. The old array object eventually gets reclaimed by the garbage collector. Array expansion is an expensive operation which should be avoided where possible. If you are able to approximate the expected size, you should use this value instead of the default.<p><b>Example</b><br/>The following instance creation would be flagged as a violation because the expected size of the collection is not specified:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new ArrayList();</code><h4><a name="com.instantiations.assist.eclipse.audit.defineLoadFactor">Define Load Factor</a></h4><p>
<b>Summary</b><br/>Define the load factor when creating instances of the classes 'HashMap', 'HashSet', 'Hashtable', and 'WeakHashMap'.<p><b>Description</b><br/>This audit rule requires a load factor to be specified when creating instances of the classes 'HashMap', 'HashSet', 'Hashtable', and 'WeakHashMap'. The load factor impacts both the size of the collection and how long it will take to perform a look-up.<p><b>Example</b><br/>The following instance creation would be flagged as a violation because the load factor is not specified:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new HashMap(42);</code><h4><a name="com.instantiations.assist.eclipse.analysis.detectMultipleIterations">Detect Multiple Iterations</a></h4><p>
<b>Summary</b><br/>Detect multiple iterations over a single collection.<p><b>Description</b><br/>A single method that contains multiple loops that iterate over the contents of a single collection may be improved by rewriting it. If it is possible to use a single loop then the loop maintenance overhead can be eliminated.<p><b>Example</b><br/>The second for loop would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < array.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.doNotCreateFinalizableObjects">Do Not Create Finalizable Objects</a></h4><p>
<b>Summary</b><br/>Finalizable objects should not be instantiated.<p><b>Description</b><br/>This audit rule checks for instance creation expressions in which the object being created implements the finalize() method. Finalization is expensive and error prone, so finalizable objects should not be used.<p><b>Example</b><br/>If the class ResourceHandle defines the finalize method, then the following instance creation expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;ResourceHandle handle = new ResourceHandle(resourceId);</code><p><img src="../../images/auditrules/audit_do_not_create_finalizable_objects.gif" width="309" height="80"></p><h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.performance.doNotUseConcatenationToConvertToString">Don't use concatenation to convert to String</a></h4><p>
<b>Summary</b><br/>Don't use concatenation to convert to String.<p><b>Description</b><br/>Concatenation with the empty string should never be used to convert something to a string. It is more efficient to use String.valueOf() to convert primitives, or toString() to convert objects.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;count = 5;&nbsp;&nbsp;&nbsp;&nbsp;return count + "";</code><h4><a name="com.instantiations.assist.eclipse.audit.efficientExpression">Efficient Expression</a></h4><p>
<b>Summary</b><br/>Some expressions are more efficient than others.<p><b>Description</b><br/>This rule finds expressions that can be replaced with other equivalent and more efficient expressions.<p><b>Example</b><br/>The expression<p><code>&nbsp;&nbsp;&nbsp;&nbsp;(new Integer("1234")).intValue()</code><p>should be replaced by<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt("1234")</code><p>because the latter expression does not create an intermediate Integer object and thus is more efficient.<h4><a name="com.instantiations.assist.eclipse.audit.emptyStringDetection">Empty String Detection</a></h4><p>
<b>Summary</b><br/>The method equals("") should not be used to determine if a String is empty.<p><b>Description</b><br/>This audit rule detects instances where Strings are detected to be empty with the &lt;String&gt;.equals("") method. Instances of "".equals(&lt;String&gt;) are also flagged as violations.<p><b>Example</b><br/>The following would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;String str = ...;<br>&nbsp;&nbsp;&nbsp;&nbsp;if(str.equals("")) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.indexArraysWithInts">Index Arrays with Ints</a></h4><p>
<b>Summary</b><br/>Arrays should be indexed with int values.<p><b>Description</b><br/>Arrays should be indexed with int values in order to avoid the run-time overhead of converting a shorter type.<p><b>Example</b><br/>The array index expression in the following code would be flagged as a violation because the loop variable "b" should be declared to be an int:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (byte b = 0; b &lt; 128; b++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[b] = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.inefficientUseOfToArray">Inefficient use of toArray()</a></h4><p>
<b>Summary</b><br/>Passing a zero-length array to <code>toArray()</code> is inefficient.<p><b>Description</b><br/>When converting a <code>Collection</code> to an array using <code>toArray()</code>, it is most efficient to pass in an array whose length is equal to the <code>Collection</code>'s size. This rule flags locations an array of some fixed length is passed in.<p><b>Example</b><br/>The use of toArray in the following code would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList foo = new ArrayList();<br>&nbsp;&nbsp;&nbsp;&nbsp;foo.toArray(new String[0]);<br></code><h4><a name="com.instantiations.assist.eclipse.audit.invokeSynchronizedMethodInLoop">Invoke Synchronized Method In Loop</a></h4><p>
<b>Summary</b><br/>Don't invoke a synchronized method within a loop.<p><b>Description</b><br/>This audit rule looks for invocations of methods that have been marked as being "synchronized" that occur within a loop. Synchronization is relatively expensive, so such calls should be made outside the loop if possible.<p><b>Example</b><br/>Given a method defined as follows:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public synchronized void recomputeCaches()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>The following invocation would be flagged as an error:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void repeatedlyInvokeIt()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recomputeCaches();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.largeNumberOfSwitchStatementCases">Large Number of Switch Statement Cases</a></h4><p>
<b>Summary</b><br/>Switch statements should not have more than 256 case clauses.<p><b>Description</b><br/>This audit rule looks for switch statements that have more than 256 case clauses. Some processors have special support for switch statements and some JITs will take advantage of such instructions when there are few enough cases.<p><b>Example</b><br/>If a switch statement with more than 256 case clauses is found, it will be flagged as a violation.<h4><a name="com.instantiations.assist.eclipse.audit.methodInvocationInLoopCondition">Method Invocation in Loop Condition</a></h4><p>
<b>Summary</b><br/>Methods should not be invoked in a loop condition.<p><b>Description</b><br/>This audit rule looks for places where a method is invoked as part of a loop condition. Unless the method returns a different value each time it is called, placing the method invocation in the loop condition will force it to be executed at least as many times as the loop body. You can often improve the performance of your code by moving the invocation before the loop.<p><b>Example</b><br/>The invocation of the method size() would be flagged as a violation in the following loop:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; list.size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_method_in_loop.gif" width="375" height="76"></p><h4><a name="com.instantiations.assist.eclipse.audit.multiplicationOrDivisionByPowersOf2">Multiplication Or Division By Powers of 2</a></h4><p>
<b>Summary</b><br/>Do not multiply or divide by powers of 2.<p><b>Description</b><br/>This audit rule checks for multiplication or division by powers of 2. "*" and "/" are an expensive operations. The shift operator is faster and more efficient.<p><b>Example</b><br/>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;list.size() * 2;</code><h4><a name="com.instantiations.assist.eclipse.audit.nestedSynchronizedCalls">Nested Synchronized Calls</a></h4><p>
<b>Summary</b><br/>Invoking one synchronized method of an object from another synchronized method of the same object affects the performance of an application.<p><b>Description</b><br/>This audit rule looks for invocations of a synchronized method from another synchronized method in the same class.<p><b>Security Implications</b><br/>Such calls both affect the performance of an application and indicate a poorly designed synchronization aspect of the code, which usually results in synchronization errors that could be exploited to create unexpected states of an application.<p><b>Example</b><br/>The following code would be flagged as a violation because it invokes one synchronized method of an object from another synchronized method of the same object:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SyncDataSource {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public synchronized Object getData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return internalGetData();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private synchronized Object internalGetData() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.precomputeConstantCalculations">Pre-compute Constant Calculations</a></h4><p>
<b>Summary</b><br/>It is faster and more accurate to pre-compute the value of a <code>Math</code> operation involving only constants.<p><b>Description</b><br/>This rule finds uses of static methods in the <code>Math</code> class which are passed constant values. It is faster, and often more accurate to pre-compute these values.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;double foo = Math.cos(0);</code><h4><a name="com.instantiations.assist.eclipse.analysis.reflectionMethodUsage">Reflection Method Usage</a></h4><p>
<b>Summary</b><br/>Don't use specific reflection methods.<p><b>Description</b><br/>Don't use Class getMethod(), getField(), getDeclaredMethod() or getDeclaredField() methods in production code.<h4><a name="com.instantiations.assist.eclipse.audit.replaceSynchronizedClasses">Replace Synchronized Classes</a></h4><p>
<b>Summary</b><br/>Synchronized classes should only be used if the synchronization is necessary. <p><b>Description</b><br/>This audit rule flags uses of synchronized classes which could be replaced with faster non-synchronized replacements.<p><b>Example</b><br/>The following would be flagged because HashMap could be used instead: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable foo = new Hashtable();</code><h4><a name="com.instantiations.assist.eclipse.audit.reusableImmutables">Reusable Immutables</a></h4><p>
<b>Summary</b><br/>Objects that cannot be modified at run-time should be created as static constants.<p><b>Description</b><br/>This audit rule finds the creation of some kinds of immutable objects. An immutable object is an object whose state cannot be modified at run-time. Such objects should be created as constants (static final fields) in order to reduce the amount of garbage that must be collected.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;new Integer(5);<br>&nbsp;&nbsp;&nbsp;&nbsp;new int[0];</code><h4><a name="com.instantiations.assist.eclipse.analysis.runtimeMethodUsage">Runtime Method Usage</a></h4><p>
<b>Summary</b><br/>Don't use specific Runtime methods.<p><b>Description</b><br/>Don't use Runtime gc(), runFinalization() or runFinalizersOnExit() methods in production code.<h4><a name="com.instantiations.assist.eclipse.audit.staticInstantiation">Static Instantiation</a></h4><p>
<b>Summary</b><br/>Do not instantiate classes which contain only static methods.<p><b>Description</b><br/>Instead of instantiating a class in order to call a static method, you should simply call Class.method(). This saves memory by not creating useless instances of classes.<p><b>Example</b><br/>Given two classes, <code>Foo</code> and <code>Bar</code>, the following would be flagged as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;public class Bar {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public doSomethingElse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Foo().doSomething();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.stringConcatenationInLoop">String Concatenation in Loop</a></h4><p>
<b>Summary</b><br/>Strings should not be concatenated within a loop.<p><b>Description</b><br/>The code to concatenate two strings is not very efficient because it creates a StringBuffer for each concatenation. When placed in a loop, this can result in the creation and collection of large numbers of temporary objects. You can create the StringBuffer before entering the loop, and append to it within the loop, thus reducing the overhead.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;String[] path;<br>&nbsp;&nbsp;&nbsp;&nbsp;String result = "";<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; path.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = result + "." + path[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_string_concatenation_in_loop.gif" width="169" height="22"></p><h4><a name="com.instantiations.assist.eclipse.audit.stringCreatedFromLiteral">String Created from Literal</a></h4><p>
<b>Summary</b><br/>Strings should not be created from a String literal.<p><b>Description</b><br/>This audit rule finds places in the code where a String literal is used to initialize a newly created String. Doing so is almost never necessary and usually only serves to waste both time and space.<p><b>Example</b><br/>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new String("Pause");</code><h4><a name="com.instantiations.assist.eclipse.audit.synchronizedInLoop">Synchronized In Loop</a></h4><p>
<b>Summary</b><br/>Synchronized statement used in a loop.<p><b>Description</b><br/>This audit rule looks for uses of the synchronized statement that occur within a loop. Synchronization is relatively expensive, so the synchronized statement should be moved to enclose the loop.<p><b>Example</b><br/>The following use of the synchronized statement would be flagged as an error:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized (monitor) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitor.doSomeWork();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.temporaryObjectCreation">Temporary Object Creation</a></h4><p>
<b>Summary</b><br/>Instances of numeric classes should not be created solely for the purpose of converting a numeric value to a string.<p><b>Description</b><br/>This audit rule checks for the creation of numeric classes where the only purpose for the object is to invoke the toString() method on it. All of the numeric classes implement a static toString() method that can do the same thing, but without the cost of creating and collecting an extra object.<p><b>Example</b><br/>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;(new Integer(age)).toString()</code><h4><a name="com.instantiations.assist.eclipse.analysis.unnecessaryToString">Unnecessary toString() Method Invocation</a></h4><p>
<b>Summary</b><br/>Remove unnecessary invocations of toString().<p><b>Description</b><br/>This audit rule flags instances of toString() that are called on String objects. Removing such invocations does not affect the program logic and can reduce timing.<p><b>Example</b><br/>The invocation of toString() below would be flagged as it can be removed.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;String string = ...;<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(string.toString());</code><h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryCast">Unnecessary Type Cast</a></h4><p>
<b>Summary</b><br/>Unnecessary type casts should be removed.<p><b>Description</b><br/>This audit rule checks for places where a value is being cast to another type and the type cast is not necessary. This includes the following cases:<br>- casting from one type to the same type,<br>- casting from one type to a supertype of that type,<br>- casting to a more specific type when the result will be assigned to a variable of the same type, or<br>- casting immediately prior to using the instanceof operator to test the type.<p><b>Example</b><br/>The following cast would be flagged because the type of the literal is already int:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int i = (int) 0;</code><p>The following cast would be flagged because the variable list can be assigned to the variable collection without the cast:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;List list = new ArrayList();<br>&nbsp;&nbsp;&nbsp;&nbsp;Collection collection = (ArrayList) list;</code><h4><a name="com.instantiations.assist.eclipse.audit.useArraycopyRatherThanALoop">Use arraycopy() Rather Than a Loop</a></h4><p>
<b>Summary</b><br/>The method arraycopy() should be used to copy arrays.<p><b>Description</b><br/>This audit rule looks for places where a loop is being used to copy the elements of one array to another array. The method System.arraycopy() is much faster at copying array elements, so it should always be used when possible.<p><b>Example</b><br/>The following loop would be flagged because it is only copying the elements of one array to another without performing any computation based on those elements:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;employees = new Employee[people.length];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; people.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;employees[i] = (Employee) people[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useAvailableConstants">Use Available Constants</a></h4><p>
<b>Summary</b><br/>Use available constants instead of creating new instances.<p><b>Description</b><br/>Some classes provide constants for commonly used values. When possible, use these constants rather than creating new instances.<p><b>Example</b><br/>The following test case would be flagged as a violation because <code>BigInteger.ZERO</code> could be used instead:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new BigInteger("0");</code><h4><a name="com.instantiations.assist.eclipse.audit.useBufferedIO">Use Buffered IO</a></h4><p>
<b>Summary</b><br/>All input and output should be buffered.<p><b>Description</b><br/>This rule finds places where non-buffered IO classes are created and are not subsequently wrapped inside a buffered form of the class.<p><b>Example</b><br/>The following FileReader creation would be flagged because it is not wrapped inside an instance of BufferedReader:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public FileReader getReader(String fileName)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new FileReader(fileName);<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>It could be fixed by rewriting the code as follows:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public Reader getReader(String fileName)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new BufferedReader(new FileReader(fileName));<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useCharRatherThanString">Use char Rather Than String</a></h4><p>
<b>Summary</b><br/>Some String literals can be replaced by a character literal to improve performance when being used as parameter to some methods.<p><b>Description</b><br/>This audit rule finds single character string literals as an argument to a method invocation where that argument can be replaced by a character literal to improve performance.<p><b>Example</b><br/>Given the following declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;String s = "hello world";</code><p>The expression<p><code>&nbsp;&nbsp;&nbsp;&nbsp;s.indexOf("d")</code><p>would be flagged as needing to be replaced by the expression<p><code>&nbsp;&nbsp;&nbsp;&nbsp;s.indexOf('d');</code><h4><a name="com.instantiations.assist.eclipse.audit.useCharAtRatherThanStartsWith">Use charAt() Rather Than startsWith()</a></h4><p>
<b>Summary</b><br/>Use charAt() rather than startsWith() when the constant is a single character string.<p><b>Description</b><br/>Use charAt(0) rather than startsWith("string constant") when the constant is a single character string. Using startsWith() with a one character argument works, but it makes several computations while preparing to compare its prefix with another string, which is unnecessary when you just want to compare one character against another.<p><b>Example</b><br/>The following method invocation would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;string.startsWith("&lt;")</code><p>because the condition could more efficiently be tested using:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;string.length() > 0 &amp;&amp; string.charAt(0) == '&lt;'</code><h4><a name="com.instantiations.assist.eclipse.audit.useStringBufferLength">Use StringBuffer length()</a></h4><p>
<b>Summary</b><br/>Test the length of a StringBuffer or StringBuilder using its length() method directly rather than converting it to a string first.<p><b>Description</b><br/>This audit rule looks for places where the length of a StringBuffer or StringBuilder is computed by first converting it to a String.<p><b>Example</b><br/>The following would be flagged: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sb = new StringBuffer("Foo");<br>&nbsp;&nbsp;&nbsp;&nbsp;if (sb.toString().length() == 0) ...</code><h4><a name="com.instantiations.assist.eclipse.audit.performance.useValueOf">Use valueOf() to wrap primitives</a></h4><p>
<b>Summary</b><br/>When wrapping primitives, always use the valueOf() method to convert them instead of calling the constructor.<p><b>Description</b><br/>The valueOf() methods in the wrapper classes cache commonly used values. It is therefore more efficient to use them, rather than to use the constructor which creates a new instance every single time.<p><b>Example</b><br/>The following would be marked as a violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Integer(5);</code><h4><a name="com.instantiations.assist.eclipse.audit.variableDeclaredInLoop">Variable Declared Within a Loop</a></h4><p>
<b>Summary</b><br/>One should be careful when declaring variables inside of for, while, or do loops. This may lead to problems especially if the variable is initialized as well.<p><b>Description</b><br/>This audit rule looks for variables that have been declared or initialized within a for, while, or do loop. <p>Declaring a variable within a loop breaks some suggested style rules. <p>Initializing a variable within a loop may indicate a problem with the program's logic. It could also lead to degraded performance.<p><b>Example</b><br/>The following declaration of the variable "event" would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;while (hasMoreEvents()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event event = getNextEvent();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_variable_declared_within_loop.gif" width="213" height="23"></p></body>
</html>
