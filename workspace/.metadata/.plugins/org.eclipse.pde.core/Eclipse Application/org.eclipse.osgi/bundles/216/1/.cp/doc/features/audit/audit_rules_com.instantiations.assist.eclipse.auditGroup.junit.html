<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - JUnit Usage</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - JUnit Usage</font></b></h1>
<b>Description</b><br/>This group contains audit rules that check for correct usage of the JUnit unit testing framework.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.disallowTestAnnotation">Disallow @Test Annotation</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.dynamicallyComposeTestSuites">Dynamically Compose Test Suites</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.failInvokedInCatch">Fail Invoked in Catch</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.invokeSuperSetUp">Invoke super.setUp() from within setUp()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.invokeSuperTearDown">Invoke super.tearDown() from within tearDown()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.jUnitChecks">JUnit Framework Checks</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingAssertInTestMethod">Missing Assert in JUnit Test Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.missingMessageInAssert">Missing Message in Assert</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.noSetUpInConstructors">No Set-up in Constructors</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.testCaseNamingConvention">Test Case Naming Convention</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useAfterAnnotationRatherThanTeardown">Use @After Annotation Rather than tearDown()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useBeforeAnnotationRatherThanSetup">Use @Before Annotation Rather than setUp()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useRunWithAnnotationRatherThanSuite">Use @RunWith and @SuiteClasses to build test suite </a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useTestAnnotationForJunitTest">Use @Test Annotation for JUnit test</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.disallowTestAnnotation">Disallow @Test Annotation</a></h4><p>
<b>Summary</b><br/>The @Test annotation should not be used.<p><b>Description</b><br/>This audit rule finds uses of the @Test annotation.<p><b>Example</b><br/>The following annotation would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;@Test<br>&nbsp;&nbsp;&nbsp;&nbsp;public void testIt()</code><h4><a name="com.instantiations.assist.eclipse.audit.dynamicallyComposeTestSuites">Dynamically Compose Test Suites</a></h4><p>
<b>Summary</b><br/>Test suites should be dynamically composed.<p><b>Description</b><br/>This audit rule checks for test cases that implement the static method suite(). Implementing this method makes it harder to extend your test suite because you have to remember to manually add any newly added test methods to the suite manually. You should take advantage of JUnit's ability to dynamically compute the test suite based on test method names. <p><b>Example</b><br/>The following method would be flagged if it appeared within a test case:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public static Test suite()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.failInvokedInCatch">Fail Invoked in Catch</a></h4><p>
<b>Summary</b><br/>Exceptions representing failure should not be caught.<p><b>Description</b><br/>This audit rule checks for test methods that catch exceptions in order to cause the test to fail by invoking one of the fail() methods. It is not necessary to catch the exception because uncaught exceptions will automatically cause the test to fail.<p><b>Example</b><br/>The following invocation of the fail() method would be flagged as a violation because it occurs within a catch block:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail("exception thrown");<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.invokeSuperSetUp">Invoke super.setUp() from within setUp()</a></h4><p>
<b>Summary</b><br/>Every implementation of setUp() should invoke super.setUp().<p><b>Description</b><br/>This audit rule looks for implementations of the method setUp() that do not invoke the inherited setUp() method.<p><b>Example</b><br/>The following definition of the method setUp() would be flagged because it does not invoke the inherited implementation of setUp():<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void setUp()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;employee = new Employee("Jane Doe");<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.invokeSuperTearDown">Invoke super.tearDown() from within tearDown()</a></h4><p>
<b>Summary</b><br/>Every implementation of tearDown() should invoke super.tearDown().<p><b>Description</b><br/>This audit rule looks for implementations of the method tearDown() that do not invoke the inherited tearDown() method.<p><b>Example</b><br/>The following definition of the method tearDown() would be flagged because it does not invoke the inherited implementation of tearDown():<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void tearDown()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;employee = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.jUnitChecks">JUnit Framework Checks</a></h4><p>
<b>Summary</b><br/>Check JUnit framework method declarations.<p><b>Description</b><br/>JUnit testing framework methods are checked for proper declarations, including spelling. The following checks are performed:<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "suite", "setUp" and "tearDown" are spelled correctly<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "suite", "setUp" and "tearDown" have no parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "suite", "setUp" and "tearDown" are void<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "suite", "setUp" and "tearDown" have the proper visibility<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "setUp" and "tearDown" are not static<br>&nbsp;&nbsp;&nbsp;&nbsp;- Check that "suite" is static<p><img src="../../images/auditrules/audit_junit_checks.gif" width="173" height="64"></p><h4><a name="com.instantiations.assist.eclipse.audit.missingAssertInTestMethod">Missing Assert in JUnit Test Method</a></h4><p>
<b>Summary</b><br/>JUnit tests should include at least one assertion.<p><b>Description</b><br/>This audit rule flags any JUnit test method that does not contain any assertions. Missing Assertions usually indicate weak or incomplete test cases. Using assert with messages provide a clear idea of what the test does. <p><b>Example</b><br/>The following test case would be flagged as a violation because it does not contain any assertions:<p><code>public class MissingAssert extends TestCase{<br>&nbsp;&nbsp;&nbsp;&nbsp;public void testSomething(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo f = findFoo();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.doWork();}}</code><h4><a name="com.instantiations.assist.eclipse.audit.missingMessageInAssert">Missing Message in Assert</a></h4><p>
<b>Summary</b><br/>Assertions should have messages.<p><b>Description</b><br/>This audit rule looks for invocations of the assert and fail methods defined in junit.framework.Assert which do not have a message. A message should be added so that the framework can provide better information about why the test failed.<p><b>Example</b><br/>The following invocation would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;assertEquals(expectedCount, actualCount);</code><h4><a name="com.instantiations.assist.eclipse.audit.noSetUpInConstructors">No Set-up in Constructors</a></h4><p>
<b>Summary</b><br/>TestCase constructors should not include any set-up code.<p><b>Description</b><br/>This audit rule checks for constructors defined in test cases that do more than invoke the superclass' constructor. Set-up should be performed in either the setUp() method or the accessor method for one of the test fixtures.<p><b>Example</b><br/>The following constructor would be flagged as a violation if it occurred within a test case class:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public MyTestCase(String testName)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(testName);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;employee = new Employee("Jane Doe");<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.testCaseNamingConvention">Test Case Naming Convention</a></h4><p>
<b>Summary</b><br/>Test case names should conform to the defined standard.<p><b>Description</b><br/>This audit rule checks the names of all test cases to ensure that they conform to the standard.<p><b>Example</b><br/>If the rule were configured to require that the word "Test" be appended to every test case's name, the following class declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTestClass extends TestCase<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_naming_conventions_test_case.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.useAfterAnnotationRatherThanTeardown">Use @After Annotation Rather than tearDown()</a></h4><p>
<b>Summary</b><br/>Use the @After annotation rather than tearDown() to clean up all the data entities required in running tests.<p><b>Description</b><br/>In JUnit 3, the tearDown method was used to clean up all data entities required in running tests. JUnit 4 skips the tearDown method and executes all methods annotated with @After after running each test.<p><b>Example</b><br/>The following test case would be flagged as a violation because it uses tearDown() rather than @After for clean up activities:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTest extends TestCase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void tearDown(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doReleaseConnection();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useBeforeAnnotationRatherThanSetup">Use @Before Annotation Rather than setUp()</a></h4><p>
<b>Summary</b><br/>Use the @Before annotation rather than setUp() to initialize the data entities required in running tests.<p><b>Description</b><br/>In JUnit 3, the setUp method was used to set up all data entities required in running tests. JUnit 4 skips the setUp method and executes all methods annotated with @Before before all tests.<p><b>Example</b><br/>The following test case would be flagged as a violation because it uses setUp() rather than @Before for setting up the Junit test:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTest extends TestCase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setUp(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doEstablishConnection();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useRunWithAnnotationRatherThanSuite">Use @RunWith and @SuiteClasses to build test suite </a></h4><p>
<b>Summary</b><br/>Use the @RunWith and @SuiteClasses annotations rather than suite() method to build test suite for JUnit <p><b>Description</b><br/>In JUnit 3, test suites are indicated by the suite() method. In JUnit 4, suites are indicated through the @RunWith and @SuiteClasses annotations. <p><b>Example</b><br/>The following test class would be flagged as a violation because it uses suite() rather than @RunWith and @SuiteClasses annotations to construct test suite:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class BadExample extends TestCase{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static Test suite(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Suite();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.useTestAnnotationForJunitTest">Use @Test Annotation for JUnit test</a></h4><p>
<b>Summary</b><br/>JUnit 4 tests should use the @Test annotation.<p><b>Description</b><br/>In JUnit 3, the framework executed all methods which started with the word test as a unit test. In JUnit 4, only methods annotated with the @Test annotation are identified as tests.<p><b>Example</b><br/>The following test case would be flagged as a violation because the test method  does not contain any @Test annotation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTest extends TestCase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void testFoo(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
