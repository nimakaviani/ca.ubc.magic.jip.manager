<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - JavaServer Faces</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - JavaServer Faces</font></b></h1>
<b>Description</b><br/>This group contains audit rules that check for correct usage of the JavaServer Faces framework.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.actionMethodReturnsUnknownValue">Action Method Returns Unknown Value</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.closeElementsInRenderer">Close Elements in Renderer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.dontEncodeMarkupInRender">Don't Encode Markup in Renderer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.incompatibleRendererType">Incompatible Renderer Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.incompleteValidationMethod">Incomplete Validation Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.inconsistentValidatorAttribute">Inconsistent Validator Attribute</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.invokeSuperRelease">Invoke super.release() Within release()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.noValidationMessage">No Validation Message</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.nonConformingBackingBeanMethod">Non-conforming Backing Bean Methods</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetComponentType">Return Constant From getComponentType</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetFamily">Return Constant From getFamily</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetRendererType">Return Constant From getRendererType</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.tagHandlerFieldNotReleased">Tag Handler Field Not Cleared</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.tagHandlerShouldImplementRelease">Tag Handler Should Implement Release</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.unknownComponentType">Unknown Component Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.unknownRendererType">Unknown Renderer Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.unegisteredValidator">Unregistered Validator</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.validationMethodNamingConvention">Validation Method Naming Convention</a></li>
      <li><a href="#com.instantiations.assist.eclipse.javaserverfaces.wrongFamilyReturned">Wrong Family Returned</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.javaserverfaces.actionMethodReturnsUnknownValue">Action Method Returns Unknown Value</a></h4><p>
<b>Summary</b><br/>Action methods should return values declared in the configuration file.<p><b>Description</b><br/>This audit rule looks for action methods in backing beans that return a constant outcome value that is not declared in faces-config.xml. Because the JSF configuration file defines navigation rules that map outcomes into pages, there is no point in returning an outcome which is never referred to in faces-config.xml.<p><b>Example</b><br/>A violation will be signaled if "checkout" outcome is never mentioned in the configuration file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class MyPageBean {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String proceedToCheckout() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "checkout";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.closeElementsInRenderer">Close Elements in Renderer</a></h4><p>
<b>Summary</b><br/>Elements that are opened in a renderer should be closed in the same method.<p><b>Description</b><br/>One of the ways a custom renderer (which is derived from javax.faces.render.Renderer) produces markup is by calling startElement/writeAttribute/endElement methods. This audit rule looks for invocations of startElement that are not followed by a proper endElement invocation within the same method.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public class CompARenderer extends Renderer {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void encodeEnd(FacesContext context, UIComponent component) throws IOException {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UIOutput outComp = (UIOutput)component;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResponseWriter writer = context.getResponseWriter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.startElement("div", component);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.writeAttribute("id", clientId, "id");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.endElement("p");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.dontEncodeMarkupInRender">Don't Encode Markup in Renderer</a></h4><p>
<b>Summary</b><br/>Hard-coding markup as Java literal strings and outputting using write() should be avoided.<p><b>Description</b><br/>This rule looks for HTML/XML tags being output inside write() calls. Placing snippets of HTML code inside Java strings and outputting them using write() calls leads to less maintainable code and potential escaping problems, and is thus prohibited by some coding standards.<p>Two possible alternatives include:<br>- use startElement(), writeAttribute(), endElement() calls to output small amounts of markup, or<br>- use some templating solution to output larger amounts of markup.<p><b>Example</b><br/>The following invocations of the write method would be flagged because the arguments contain markup.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class CompARenderer extends Renderer {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void encodeEnd(FacesContext context, UIComponent component)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IOException {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResponseWriter writer = context.getResponseWriter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write("&lt;div class="bpui_compA_popMid"&gt;");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write("&lt;/div&gt;");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.incompatibleRendererType">Incompatible Renderer Type</a></h4><p>
<b>Summary</b><br/>The method getRendererType must return a renderer compatible with the type of component specified by the getComponentType method.<p><b>Description</b><br/>This audit rule looks for subclasses of UIComponentTag that return a literal string or a string constant from getComponentRenderer() such that the returned string denotes a renderer which cannot render the component specified by the getComponentType() method's return value.<p><b>Example</b><br/>Given the following XML:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;render-kit&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;renderer&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;component-family&gt;FamilyA&lt;/component-family&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;renderer-type&gt;RendererA&lt;/renderer-type&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;renderer-class&gt;renderers.RendererA&lt;/renderer-class&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/renderer&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/render-kit&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;component&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;component-type&gt;ComponentB&lt;/component-type&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;component-class&gt;components.ComponentB&lt;/component-class&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;component-extension&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;component-family&gt;FamilyB&lt;/component-family&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/component-extension&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/component&gt;</code><p>and the following component code:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class ComponentB extends UIOutput {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getFamily() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "FamilyB";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>the return value of the getRendererType() method of the following class will be flagged as violation because the specified renderer cannot render components of the specified family.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class ViolatingTag extends UIComponentTagBase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getRendererType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "RendererA";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getComponentType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "ComponentB";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.incompleteValidationMethod">Incomplete Validation Method</a></h4><p>
<b>Summary</b><br/>Validation methods should either invoke setValid() or throw ValidatorException.<p><b>Description</b><br/>This audit rule looks for validation methods that neither invoke setValid() nor throw ValidatorException, where a validation method is either the processValidation method defined by the Validator interface or a method with a signature of (FacesContext, UIComponent, Object) in a backing bean. These are the two ways for a validation method to signal invalid input to the framework (and if the input cannot be invalid, the validator is not needed).<p><b>Example</b><br/>The following validator will be flagged as a violation because it neither calls UIInput.setValid() nor throws a ValidatorException.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyValidator implements Validator {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void validate(FacesContext context, UIComponent comp, Object value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Validating value " + value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.inconsistentValidatorAttribute">Inconsistent Validator Attribute</a></h4><p>
<b>Summary</b><br/>A validator's attribute type must match the configuration file.<p><b>Description</b><br/>This audit rule looks for accessor methods (getters and setters) in implementations of the Validator interface whose return type or parameter type (as appropriate) does not match the type specified in the configuration file.<p><b>Example</b><br/>Given the following fragment in the faces-config.xml file:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;validator&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Checks if the given value matches the ultimate answer.&lt;/description&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;validator-id&gt;MyValidator&lt;/validator-id&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;validator-class&gt;validators.MyValidator&lt;/validator-class&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;...&lt;/description&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute-name&gt;pattern&lt;/attribute-name&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute-class&gt;java.lang.String&lt;/attribute-class&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attribute&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/validator&gt;<br></code><p>The method getPattern() of the following validator will be flagged as a violation because it's return type does not match the attribute type specified in the configuration.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyValidator implements Validator {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Integer getPattern() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Integer(42);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.invokeSuperRelease">Invoke super.release() Within release()</a></h4><p>
<b>Summary</b><br/>An overriden release() method should invoke the superclass implementation.<p><b>Description</b><br/>This audit rule looks for release() methods implemented by custom tag handlers that do not invoke super.release() in the body of the method.<p><b>Example</b><br/>The release() method of the following class will be flagged as a violation because it does not contain an invocation of super.release().<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTag extends UIComponentClassicTagBase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String foo;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void release() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.noValidationMessage">No Validation Message</a></h4><p>
<b>Summary</b><br/>Validation methods should indicate why the input is invalid.<p><b>Description</b><br/>A validation method can signal invalid input either by invoking setValid with an argument of false, or by throwing a ValidatorException. If setValid is invoked, the method addMessage should be invoked to pass a message back to the user explaining why the input is not valid. If an exception is thrown, it should have a message that serves the same purpose.This audit rule looks for validation methods that do not either invoke addMessage() or include a message when creating the ValidatorException.<p><b>Example</b><br/>The following validator will be flagged as violation because it neither invokes UIInput.addMessage() nor throws a ValidatorException.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyValidator implements Validator {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void validate(FacesContext context, UIComponent comp, Object value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Validating value " + value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.nonConformingBackingBeanMethod">Non-conforming Backing Bean Methods</a></h4><p>
<b>Summary</b><br/>Verifies that parameters and return types of bean's public methods are those expected by the framework.<p><b>Description</b><br/>Public methods of backing beans are called from inside the JSF framework and are expected to have some well-defined signatures. The methods can either be:<p>- getters/setters of bean properties (to be bound to JSP components or tag attributes)<p>- event handlers (accepting an instance of an event class and returning nothing)<p>- action methods (accepting nothing and returning a String)<p>- validation methods (accepting FacesContext, UIComponent, Object arguments and returningnothing; usually include "validate" prefix in their name)<p>A method with a signature not matching one of the listed ones will be caught by this rule.<p><b>Example</b><br/>The following method will be marked as violation because it conforms to neither of the allowed specs.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyBackingBean {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void violatingMethod(int x, int y) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetComponentType">Return Constant From getComponentType</a></h4><p>
<b>Summary</b><br/>The method getComponentType() is expected to return a constant string.<p><b>Description</b><br/>This audit rule looks for implementations of getComponentType() that return a value other than a constant string (i.e. a literal or a final static field). Because the value returned must match the one in the XML file, there is no point in doing any calculations to produce it. Doing so reduces readability of the source and also prevents automatic checking of the return value.<p><b>Example</b><br/>The following return statement will be flagged as a violation.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButtonTag extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getComponentType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "CheatyButtonNr" + System.currentTimeMillis();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetFamily">Return Constant From getFamily</a></h4><p>
<b>Summary</b><br/>The method getFamily() is expected to return a constant string.<p><b>Description</b><br/>This audit rule looks for implementations of getFamily() that return a value other than a constant string (i.e. a literal or a final static field). Because the value returned must match the one in the XML file, there is no point in doing any calculations to produce it. Doing so reduces readability of the source and also prevents automatic checking of the return value.<p><b>Example</b><br/>The following return statement will be flagged as a violation.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButton extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getFamily() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "RoundButtonNr" + System.currentTimeMillis();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.returnConstantFromGetRendererType">Return Constant From getRendererType</a></h4><p>
<b>Summary</b><br/>The method getRendererType() is expected to return a constant string.<p><b>Description</b><br/>This audit rule looks for implementations of getRendererType() that return a value other than a constant string (i.e. a literal or a final static field). Because the value returned must match the one in the XML file, there is no point in doing any calculations to produce it. Doing so reduces readability of the source and also prevents automatic checking of the return value.<p><b>Example</b><br/>The following return statement will be flagged as a violation.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButtonTag extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getRendererType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "RoundButtonNr" + System.currentTimeMillis();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.tagHandlerFieldNotReleased">Tag Handler Field Not Cleared</a></h4><p>
<b>Summary</b><br/>Checks for custom tag handler fields that have not been cleared in release().<p><b>Description</b><br/>A practice recommended by the JSF tutorial is to override the release() method and clear non-final instance fields in every custom tag handler. This audit rule looks for custom tag handlers that have non-final instance fields of non-primitive types that are not cleared in the release() method.<p><b>See Also</b><br/>The audit rule "Tag Handler Should Implement Release" checks for the existance of the release() method in classes that need it.<p><b>Example</b><br/>The field "bar" of the following class will be marked is violation because it is not assigned to within the release() method.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTag extends UIComponentClassicTagBase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String foo;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String bar;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void release() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.tagHandlerShouldImplementRelease">Tag Handler Should Implement Release</a></h4><p>
<b>Summary</b><br/>Custom tag handlers should implement the release() method.<p><b>Description</b><br/>A practice recommended by the JSF tutorial is to override the release() method and clear non-final instance fields in every custom tag handler. This audit rule looks for custom tag handlers that have non-final instance fields of non-primitive types that are not cleared in the release() method.<p><b>See Also</b><br/>The audit rule "Tag Handler Field Not Cleared" checks for fields that should be cleared in the release() method but are not.<p><b>Example</b><br/>The following class will be flagged as a violation because it has a field to release but does not override the release() method.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyTag extends UIComponentClassicTagBase {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String foo;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.unknownComponentType">Unknown Component Type</a></h4><p>
<b>Summary</b><br/>The method getComponentType should return the name of a declared component type.<p><b>Description</b><br/>This audit rule looks for subclasses of UIComponentTagBase that implement a getComponentType method that returns a constant value that is not mentioned in faces-config.xml. Because the JSF configuration file lists all component types in the project, there is no point in returning a component type that is not defined in faces-config.xml.<p><b>Example</b><br/>A violation will be signalled if "RoundButton" component type is not defined in the configuration file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButtonTag extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getComponentType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "RoundButton";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.unknownRendererType">Unknown Renderer Type</a></h4><p>
<b>Summary</b><br/>The method getRendererType should return the name of a declared renderer.<p><b>Description</b><br/>This audit rule looks for subclasses of UIComponentTagBase that implement a getRendererType method that returns a constant value that is not mentioned in faces-config.xml. Because the JSF configuration file lists all renderers in the project, there is no point in returning a renderer type that is not defined in faces-config.xml.<p><b>Example</b><br/>A violation will be flagged if the "RoundButton" renderer is not defined in the configuration file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButtonTag extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getRendererType() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "RoundButton";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.unegisteredValidator">Unregistered Validator</a></h4><p>
<b>Summary</b><br/>All implementations of the Validator interface should be registered in the configuration file.<p><b>Description</b><br/>This audit rule looks for non-abstract implementations of the Validator interface that are not registered in faces-config.xml. Implementations that are not registered will never be used by the framework.<p><b>Example</b><br/>The following class will be marked as violation if it is not registered in the configuration file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class UnregisteredValidator implements Validator {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void validate(FacesContext context, UIComponent comp, Object value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.validationMethodNamingConvention">Validation Method Naming Convention</a></h4><p>
<b>Summary</b><br/>Verifies that the first component of a backing bean's validation method's name is "validate".<p><b>Description</b><br/>By a common convention, the names of validation methods in backing beans start with word "validate". This audit rule looks for violations of this convention.<p><b>Example</b><br/>The following method will be flagged because it's name does not start with "validate".<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyBackingBean {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void emailValidator(FacesContext context, UIComponent comp, Object value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.javaserverfaces.wrongFamilyReturned">Wrong Family Returned</a></h4><p>
<b>Summary</b><br/>The method getFamily should return family declared in the configuration file.<p><b>Description</b><br/>This audit rule looks for subclasses of UIComponentBase that implement a getFamily method that returns a constant value that does not match the one from faces-config.xml. The value returned from the getFamily() method must match the value specified for the component in the application configuration file.<p><b>Example</b><br/>A violation will be signalled if "Checkbox" is not the component family specified for "RoundButton" component in the configuration file.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class RoundButton extends UIComponentTag {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getFamily() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Checkbox";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
