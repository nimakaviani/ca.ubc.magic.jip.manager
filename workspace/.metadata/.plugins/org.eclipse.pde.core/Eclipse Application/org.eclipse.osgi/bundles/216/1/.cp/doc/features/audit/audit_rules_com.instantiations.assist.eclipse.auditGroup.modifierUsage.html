<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Modifier Usage</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Modifier Usage</font></b></h1>
<b>Description</b><br/>This group contains audit rules that check your code for incorrect uses of modifiers.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.audit.anonymousClassMemberVisibility">Anonymous Class Member Visibility</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.avoidPackageScopeAuditRule">Avoid Package Scope</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.classShouldBeFinal">Class Should Be Final</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.finalMethodParameterInInterface">Final Method Parameter In Interface</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.instanceFieldVisibility">Instance Field Visibility</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.modifierOrder">Modifier Order</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.noAbstractMethods">No Abstract Methods</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.noPublicMembers">No Public Members</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nonBlankFinalInstanceField">Non-blank Final Instance Field</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nonPrivateConstructorInStaticType">Non-private Constructor in Static Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nonProtectedConstructorInAbstractType">Non-protected Constructor in Abstract Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.obsoleteModifierUsage">Obsolete Modifier Usage</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.protectedInFinalClass">Protected Member in Final Class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.publicConstructorInNonPublicType">Public Constructor in Non-public Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.publicNestedTypeInPackageVisible">Public Nested Type in Package Visible Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.transientFieldInNonSerializable">Transient Field in Non-Serializable Class</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryFinalMethod">Unnecessary Final Method</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.variableShouldBeFinal">Variable Should Be Final</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.audit.anonymousClassMemberVisibility">Anonymous Class Member Visibility</a></h4><p>
<b>Summary</b><br/>Members of anonymous classes should be private.<p><b>Description</b><br/>This audit rule checks the visibility of all fields and methods within an anonymous class to ensure that they are declared private (except for methods that override an inherited method). Such fields and methods should be declared private to make it clear that they cannot be accessed outside the anonymous class (and to make it easier to detect dead code).<p><b>Example</b><br/>The following field declaration would be flagged as a violation because it is declared as being public:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new Runnable() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_anonymous_class_member_visibility.gif" width="440" height="71"></p><h4><a name="com.instantiations.assist.eclipse.analysis.avoidPackageScopeAuditRule">Avoid Package Scope</a></h4><p>
<b>Summary</b><br/>Only use public, protected or private scopes.<p><b>Description</b><br/>This audit flags all inner classes, constructors, methods, and fields that have a package scope.<p>Note: non-inner classes and interfaces cannot syntactically be declared protected or private, thus since a non-inner class/ interface isn't more secure if it has package scope instead of a public scope, this audit does not flag interfaces or non-inner classes that have a package scope.<p>Also note: the resolutions (fixes) for flagged instances of this audit include the insertion of the "public" modifier as well as "private" and "protected" modifiers. However, changing a modifier from package scope to a public scope does not make the code more secure, and is included only because it is expected that the public modifier is used.<p><b>Security Implications</b><br/>Classes, methods and fields with package scope (default scope) can be accessed from all code within the same package, including code written by adversaries.<p><b>Example</b><br/>The following will all be flagged since they all have a package scope: the constructor "Example", the class "InnerClass", the method "some_method", and the integer "x":<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class Example {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example(){super();}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class InnerClass{}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void some_method(){/* do nothing */}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.eclipse.analysis.audit.security.classShouldBeFinal">Class Should Be Final</a></h4><p>
<b>Summary</b><br/>Classes that do not have subclasses should be <code>final</code>.<p><b>Description</b><br/>This audit rule looks for classes that do not have any subclasses but are not marked as <code>final</code>. Note that this rule is only useful if all of the classes in the product are loaded into the development environment.<p><b>Security Implications</b><br/>The ability to extend classes can be abused by a malicious user. They can be used to obtain access to information contained in the parent class.<p><b>Example</b><br/>The following class would be flagged as a violation because it does not have any subclasses, and it isn't marked as <code>final</code>:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class MyClass<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.finalMethodParameterInInterface">Final Method Parameter In Interface</a></h4><p>
<b>Summary</b><br/>Method parameters in interfaces should not be final.<p><b>Description</b><br/>This audit rule flags any final method parameters defined in interfaces. It is unnecessary to mark an interface methods's parameters as final, since there is no implementation associated with an interface, and making a parameter final only affects the implementation.<p><b>Example</b><br/>The following declaration of the final parameters a and b would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;interface foo {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void add(final int a, final int b);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.instanceFieldVisibility">Instance Field Visibility</a></h4><p>
<b>Summary</b><br/>Instance fields should have an appropriate visibility.<p><b>Description</b><br/>This audit rule checks the visibility of all non-static fields to ensure that it is one of the allowed visibilities.<p><b>Example</b><br/>If the rule were configured to only allow private instance fields, then the following field declaration would be flagged as a violation because it is declared as being public:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int x;</code><p><img src="../../images/auditrules/audit_instance_field_visibility.gif" width="404" height="80"></p><h4><a name="com.instantiations.assist.eclipse.audit.modifierOrder">Modifier Order</a></h4><p>
<b>Summary</b><br/>Modifiers should always appear in the standard order.<p><b>Description</b><br/>This audit rule checks the order in which the modifiers were declared and reports any deviation from the standard (Sun defined) order.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;final static public int ANSWER = 42;</code><h4><a name="com.instantiations.assist.eclipse.audit.noAbstractMethods">No Abstract Methods</a></h4><p>
<b>Summary</b><br/>Classes should not be declared abstract unless they define abstract methods.<p><b>Description</b><br/>This audit rule finds classes that are declared to be abstract but that do not define any abstract methods.<p><b>Example</b><br/>The following class declaration would be flagged as a violation because it does not define any abstract methods:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public abstract class Widget<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img border="0" src="../../images/auditrules/audit_abstract_methods.gif" width="251" height="25"></p><h4><a name="com.instantiations.assist.eclipse.audit.noPublicMembers">No Public Members</a></h4><p>
<b>Summary</b><br/>Classes should not be declared public unless they define public members.<p><b>Description</b><br/>This audit rule finds classes that are declared to be public but that do not define any public members or at least one protected constructor. Consider restricting such classes to package scope.<h4><a name="com.instantiations.assist.eclipse.audit.nonBlankFinalInstanceField">Non-blank Final Instance Field</a></h4><p>
<b>Summary</b><br/>Final instance fields should be blank.<p><b>Description</b><br/>This audit rule finds instance fields that are marked as final and have a value assigned to them in the declaration. If the value of the field is the same for all instances, which it must be in this case, it should be a static field instead. If the value can be different in different instances, then either the field should not be final or the field should be assigned its value in a constructor.<p><b>Example</b><br/>The following field declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private final int maxItemCount = 64;</code><h4><a name="com.instantiations.assist.eclipse.audit.nonPrivateConstructorInStaticType">Non-private Constructor in Static Type</a></h4><p>
<b>Summary</b><br/>Constructors in classes containing only static members should be private.<p><b>Description</b><br/>This audit rule finds non-private constructors in classes containing only static members. There is no value in creating an instance of a type that contains only static members. To prevent such instantiation, ensure that type has a single, no-argument, private constructor and no other constructors.<p><b>Example</b><br/>The following class declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Utilities<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static int getSize(List list)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.nonProtectedConstructorInAbstractType">Non-protected Constructor in Abstract Type</a></h4><p>
<b>Summary</b><br/>Constructors in abstract classes should be protected.<p><b>Description</b><br/>This audit rule finds non-protected constructors in abstract classes. Constructors in an abstract class can only be called from an instantiating subclass. Marking all constructors protected will help indicate this.<p><b>Example</b><br/>The constructor in the following class declaration would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public abstract class Widget<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Widget()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.obsoleteModifierUsage">Obsolete Modifier Usage</a></h4><p>
<b>Summary</b><br/>Obsolete modifiers should not be used.<p><b>Description</b><br/>There are a number of modifiers that can validly be specified according to the Java Language Specification, but which Sun strongly discourages the use of. This audit rule checks for places in which those modifiers are used.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public abstract interface SpecialObject<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_obsolete_modifier_usage.gif" width="320" height="131"></p><h4><a name="com.instantiations.assist.eclipse.audit.protectedInFinalClass">Protected Member in Final Class</a></h4><p>
<b>Summary</b><br/>Members of a final class should not be protected.<p><b>Description</b><br/>This audit rule finds members that have a visibility of protected but are defined in a final class. There is no reason for them to be given a visibility of protected because there cannot be any subclasses.<p><b>Example</b><br/>The method getSalary() would be flagged as a violation in the following example:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final class Employee<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected double getSalary()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.publicConstructorInNonPublicType">Public Constructor in Non-public Type</a></h4><p>
<b>Summary</b><br/>Constructors in non-public classes should not be public.<p><b>Description</b><br/>This audit rule finds public constructors in non-public classes. There is no value in providing a public constructor because a non-public class cannot be instantiated outside the package in which it is defined. Reduce the access of the constructor to match that of the class itself.<p><b>Example</b><br/>The constructor in the following example would be flagged as a violation because the class only has package visibility:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class EmployeeData<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public EmployeeData()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.publicNestedTypeInPackageVisible">Public Nested Type in Package Visible Type</a></h4><p>
<b>Summary</b><br/>Types declared within package visible types should not be public.<p><b>Description</b><br/>This audit rule looks for declarations of public nested types within a package visible type. Because the outer type limits the visibility of the nested type, there is no reason for it to be declared as public, and such a declaration can be misleading.<p><b>Example</b><br/>The following nested type would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class OuterClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class InnerClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.transientFieldInNonSerializable">Transient Field in Non-Serializable Class</a></h4><p>
<b>Summary</b><br/>Classes that do not implement java.io.Serializable should not declare fields as transient.<p><b>Description</b><br/>This audit rule looks for declarations of fields that are transient in classes that do not implement the interface java.io.Serializable.<p><b>Example</b><br/>The following field would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;class NonSerializable<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private transient int value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryFinalMethod">Unnecessary Final Method</a></h4><p>
<b>Summary</b><br/>Methods in a final class should not be declared as final.<p><b>Description</b><br/>This audit rule looks for methods that are declared as being final that are defined in a class that is also declared as final. It is not necessary to declare the method to also be final because no subclass of the class could ever be defined.<p><b>Example</b><br/>The "final" modifier on the following method would be flagged as a violation because the class is also marked as being final"<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final class Point<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final int getX()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.variableShouldBeFinal">Variable Should Be Final</a></h4><p>
<b>Summary</b><br/>Variables that are assigned only once should be final. Variables marked as final communicate additional information to the reader about how the variable is supposed to be used.<p><b>Description</b><br/>This audit rule finds<p>* private fields that have a value assigned in an initializer or in a constructor and no where else,<p>* method parameters that are not assigned a value in the method,<p>* catch parameters that are not assigned a value in the catch block, and<p>* local variables that have a value assigned in their initializer and no where else.<p>The variable should be marked as final indicating that the value of the variable does not change through out the variable's lifetime.<p><b>Security Implications</b><br/>When a field is only assigned a value in one place, this usually indicates that the field is not supposed to be changed during the life cycle of the object. By marking the field as <code>final</code> you reduce the risk that a malicious user can alter its value and thus create an unexpected situation with unpredictable results.<p><img src="../../images/auditrules/audit_variable_should_be_final.gif" width="166" height="44"></p></body>
</html>
