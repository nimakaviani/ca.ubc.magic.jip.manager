<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Semantic Errors</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Semantic Errors</font></b></h1>
<b>Description</b><br/>This group contains audit rules that report coding practices that often indicate that the code will not perform the way the program might expect.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.allowCompareToToThrowExceptions">Allow compareTo to Throw Exceptions</a></li>
      <li><a href="#com.instantiations.assist.eclipse.arrayAndNonArrayComparison">Array and non-Array Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.arrayComparison">Array Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidOctalLiterals">Avoid Octal Literals</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidStringBufferInstantiationWithChar">Avoid StringBuffer Instantiation With Character Literal</a></li>
      <li><a href="#com.instantiations.assist.eclipse.incompatibleComparisonOfTypes">Comparison Of Incompatible Types</a></li>
      <li><a href="#com.instantiations.eclipse.analysis.audit.security.containerShouldNotContainItselfAsElement">Container Should Not Contain Itself As Element</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.dereferencingNullPointer">Dereferencing Null Pointer</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.floatComparison">Float Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.incompleteStateStoring">Incomplete State Storing</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.inconsistentConversionUsingToArray">Inconsistent Conversion Using toArray()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.incorrectArgumentType">Incorrect Argument Type</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.incorrectUseOfEqualsAndCompareTo">Incorrect Use of equals() and compareTo()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.nullPointerDereference">Null Pointer Dereference</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.obeyEqualsContract.obeyGeneralContractOfEquals">Obey General Contract of Equals</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.overridingEqualsAndHashCode">Override both equals() and hashCode()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.questionableAssignment">Questionable Assignment</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.redundantAssignment">Redundant Assignment</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.stringComparison">String Comparison</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unhashableClassInHashedCollection">Unhashable class in hashed collection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unnecessaryCast">Unnecessary Type Cast</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useDeepArraysMethods">Use deep Arrays methods when necessary</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.useNoSuchElementException">Use NoSuchElementException in next()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.wrongIntegerTypeSuffix">Wrong Integer Type Suffix</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.allowCompareToToThrowExceptions">Allow compareTo to Throw Exceptions</a></h4><p>
<b>Summary</b><br/>The compareTo method is expected to throw ClassCastException and NullPointerException.<p><b>Description</b><br/>It is not necessary to test the value of the argument to compareTo prior to casting it. If the argument is null a NullPointerException should be thrown. If it is of the wrong type a ClassCastException should be thrown. This rule finds implementations of the compareTo method that explicitly catch those exceptions when they should not.<p><b>Example</b><br/>The following implementation of compareTo tests the argument against null and uses the instanceof operator to check the type of the argument:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int compareTo(Object o)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (!(o instanceof MyClass)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value - ((MyClass) o).value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>It should be replaced by the following, cleaner, implementation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int compareTo(Object o)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value - ((MyClass) o).value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.arrayAndNonArrayComparison">Array and non-Array Comparison</a></h4><p>
<b>Summary</b><br/>Avoid using the <code>equals()</code> method to compare array and non-array types because this call always returns false.<p><b>Description</b><br/>This rule looks for places where the <code>equals()</code> method is used to compare array and non-array types. Such a comparison will always return <code>false</code>, and thus usually indicates an error.<p><b>Example</b><br/>The following code whould be flagged as a violation because it contains an incorrect comparison:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod(String a[]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a.equals("INCORRECT"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.assist.eclipse.audit.arrayComparison">Array Comparison</a></h4><p>
<b>Summary</b><br/>Arrays should not be compared using equals (==), not equals (!=), or equals().<p><b>Description</b><br/>Arrays should always be compared using one of the comparison methods defined for arrays. This audit rule looks for comparisons using either the equals (==) or not equals (!=) operators or the equals() method.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;char[] currentName, proposedName;<p>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;if (proposedName != currentName) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidOctalLiterals">Avoid Octal Literals</a></h4><p>
<b>Summary</b><br/>Avoid the use of octal literals.<p><b>Description</b><br/>This audit rule finds uses of octal literals (numeric literals that begin with a zero). Numeric literals should be expressed in either decimal or hexidecimal formats in order to avoid confusion.<p><b>Example</b><br/>The following numeric literal would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;0010</code><h4><a name="com.instantiations.assist.eclipse.audit.avoidStringBufferInstantiationWithChar">Avoid StringBuffer Instantiation With Character Literal</a></h4><p>
<b>Summary</b><br/>Character literals should not be used as the argument to the constructor of either a StringBuffer or StringBuilder.<p><b>Description</b><br/>This audit rule finds places in the code where a character literal is used to initialize a newly created StringBuffer or StringBuilder. This has the (presumably) unintended result of converting the character literal into an int to set the initial size of the StringBuffer or StringBuilder.<p><b>Example</b><br/>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;new StringBuffer('c');</code><h4><a name="com.instantiations.assist.eclipse.incompatibleComparisonOfTypes">Comparison Of Incompatible Types</a></h4><p>
<b>Summary</b><br/>Avoid comparing objects whose types do not have any common parent classes or interfaces using the <code>equals</code> method.<p><b>Description</b><br/>This audit rule looks for places where incompatible types are compared using the <code>equals</code> method. Such a comparison will always return <code>false</code>, and thus usually indicates an error.<p><b>Example</b><br/>The following invocation of the <code>equals</code> method will be marked as a violation because the types are incompatible:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.........<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;public void myMethod(MyClass obj, String a[]) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(obj.equals(a))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code><h4><a name="com.instantiations.eclipse.analysis.audit.security.containerShouldNotContainItselfAsElement">Container Should Not Contain Itself As Element</a></h4><p>
<b>Summary</b><br/>Re-adding objects in a container to its contents is usually a typo which could result in an inpredicted behaviour of a code.<p><b>Description</b><br/>This audit rule violates container storing operations such as <code>addAll()</code> or <code>removeAll()</code> when they are invoked with the same container as an argument.<p><b>Security Implications</b><br/>Such invocation is usually a typo which indicates a plain error in a logic of the code. Such code will not function as expected and could result in any security threat from Denial of Service to data leaks when used in security-sensitive areas.<p><b>Example</b><br/>The following method is supposed to remove all banned users from the given list of users trying to access secure data but will fail because of the typo; this typo would thus be marked as violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;protected void filterBannedUsers(List allUsers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List bannedUsers = new ArrayList();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator i = allUsers.iterator(); i.hasNext();) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User user = (User) i.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isBanned(user)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bannedUsers.add(user);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.dereferencingNullPointer">Dereferencing Null Pointer</a></h4><p>
<b>Summary</b><br/>A null value is dereferenced as if it had an object value.<p><b>Description</b><br/>Method invocation and field access on null values will cause errors. In expressions following explicit comparisons to null, such as (x == null &amp;&amp; x.getValue()), dereferencing the null pointer will cause an error. These usually indicate typographical errors such as substituting &amp;&amp; for || in the boolean expression.<p><b>Example</b><br/>The method invocation in the following condition would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (object == null &amp;&amp; object.getData() == null) ...</code><h4><a name="com.instantiations.assist.eclipse.audit.floatComparison">Float Comparison</a></h4><p>
<b>Summary</b><br/>Floating-point values should not be compared using equals (==) or not equals (!=).<p><b>Description</b><br/>This audit rule finds places where two floating-point values are compared using either the equals (==) or not equals (!=) operators. The problem is that floating-point values are not exact, and floating-point operations sometimes introduce rounding errors. This sometimes results in getting the wrong result from equality-based comparisons.<p><b>Example</b><br/>Given two floating point variables:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;double oneThird = 1.0 / 3.0;<br>&nbsp;&nbsp;&nbsp;&nbsp;double anotherThird = (2.0 / 3.0) - oneThird;</code><p>The following expression would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (oneThird == anotherThird)</code><h4><a name="com.instantiations.assist.eclipse.audit.incompleteStateStoring">Incomplete State Storing</a></h4><p>
<b>Summary</b><br/>The methods <code>saveState()</code> and <code>restoreState()</code> should both be implemented at the same level of class hierarchy.<p><b>Description</b><br/>It is improper to implement the <code>saveState()</code> and <code>restoreState()</code> methods of a <code>StateHolder</code> on different levels of a class hierarchy. This approach is error-prone and should be avoided. This rule looks for classes that implement only one or the other of these method but not both.<p><b>Security Implications</b><br/>This approach is error-prone and thus can aid an attacker.<p><b>Example</b><br/>The following class implements only one of the two state methods and will be marked as violation: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public abstract class AbstractStateHolder implements StateHolder {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Object saveState(FacesContext ctx) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.inconsistentConversionUsingToArray">Inconsistent Conversion Using toArray()</a></h4><p>
<b>Summary</b><br/>Inconsistent conversion using <code>toArray()</code> will cause a <code>ClassCastException</code>.<p><b>Description</b><br/>This audit rule finds places where <code>toArray()</code> is invoked, but the result is cast to an incompatible type.<p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;List foo = new ArrayList();<br>&nbsp;&nbsp;&nbsp;&nbsp;(String[]) foo.toArray(new Integer[0]);<br></code><h4><a name="com.instantiations.assist.eclipse.audit.incorrectArgumentType">Incorrect Argument Type</a></h4><p>
<b>Summary</b><br/>The actual type of an argument is incorrect.<p><b>Description</b><br/>Several methods defined in the interface java.util.Map (and java.util.concurrent.ConcurrentMap) are declared with parameters of type Object even though they are expected to be of the same type as either the keys or the values. This audit rule looks for invocations of these method in which the argument type does not conform with the expected type. Even though the compiler can't identify such invocations as an error, they are almost always wrong.<p>Specifically, the rule looks for invocations of the following methods:<p><code>java.util.Map.containsKey(Object)<br>java.util.Map.containsValue(Object)<br>java.util.Map.get(Object)<br>java.util.Map.remove(Object)<br>java.util.concurrent.ConcurrentMap.remove(Object, Object)</code><p><b>Example</b><br/>Given the following declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, String&gt; nameMap;</code><p>The following invocation would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;nameMap.get(new Integer(42))</code><h4><a name="com.instantiations.assist.eclipse.audit.incorrectUseOfEqualsAndCompareTo">Incorrect Use of equals() and compareTo()</a></h4><p>
<b>Summary</b><br/>If <code>compareTo()</code> is overridden for a type, then <code>equals()</code> should be overridden as well.<p><b>Description</b><br/>When implemented, the <code>compareTo()</code> method should override <code>compareTo(Object)</code>, and it should be consistent with <code>equals()</code>. That is, <code>a.compareTo(b)</code> should return <code>0</code> if and only if <code>a.equals(b)</code> returns <code>true</code>.<p>Specifically, this rule flags cases where <code>compareTo()</code> is overridden but <code>equals()</code> is not and cases where <code>compareTo()</code> is overloaded instead of overridden.<p><b>Example</b><br/>The following would be flagged as a violation, since it overrides compareTo, but not equals:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int compareTo(Object o) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.nullPointerDereference">Null Pointer Dereference</a></h4><p>
<b>Summary</b><br/>Null pointers should not be dereferenced.<p><b>Description</b><br/>This audit rule checks for places where a value that is known to be null is being dereferenced in a way that is guaranteed to produce a NullPointerException. <p><b>Example</b><br/>The following code will cause a violation because the variable <code>o</code> is known to have a null value:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Object o = null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(o.getClass().getName());</code><h4><a name="com.instantiations.assist.eclipse.analysis.audit.rule.effectivejava.obeyEqualsContract.obeyGeneralContractOfEquals">Obey General Contract of Equals</a></h4><p>
<b>Summary</b><br/>Obey the general contract when overriding equals().<p><b>Description</b><br/>The equals() method defined in Object is intended to be overridden by subclasses but each subclass must obey the general contract specified by the superclass. Classes should not use the name "equals" for methods that take any parameters other than a single Object. The body of the method should be coded defensively to accept any class of object as its argument.<p><b>Example</b><br/>The style of equals() definition that this rule looks for is this:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object arg) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this == arg)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(arg instanceof Foo))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo fooArg = (Foo) arg;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>"Foo" is the name of a type, which is either the class that declares this equals() method or an interface that is implemented by that class.<h4><a name="com.instantiations.assist.eclipse.audit.overridingEqualsAndHashCode">Override both equals() and hashCode()</a></h4><p>
<b>Summary</b><br/>Classes should override both equals() and hashCode() if they override either.<p><b>Description</b><br/>This audit rule finds classes in which either the equals() or hashCode() method has been overridden, but not both.<p><b>Example</b><br/>The following class declaration will be flagged as a violation because it overrides the method equals() but does not override the method hashCode():<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Employee<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object object)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return object instanceof Employee<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; getName().equals(((Employee) object).getName());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.questionableAssignment">Questionable Assignment</a></h4><p>
<b>Summary</b><br/>Questionable assignments may lead to semantic errors.<p><b>Description</b><br/>This audit rule checks for assignments to for loop variables within the loop body or assignments to method parameters within the body of the method. While these may sometimes prove useful they often have unintended side effects. Be sure you really mean to make these assignments!<p><b>Example</b><br/>The assignment to "index" in the following method would be flagged as a violation because it is a method parameter:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int lastIndexOf(Object[] array, Object value, int index)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = array.size() - 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (index &gt;= 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_questionable_assignment.gif" width="227" height="42"></p><h4><a name="com.instantiations.assist.eclipse.audit.redundantAssignment">Redundant Assignment</a></h4><p>
<b>Summary</b><br/>Redundant assignments should never be used.<p><b>Description</b><br/>This audit rule checks for the assignment of a variable to itself. This often indicates a missing qualifier, such as "this." for one or the other of the identifiers.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public void setName(String name)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.stringComparison">String Comparison</a></h4><p>
<b>Summary</b><br/>Strings should not be compared using equals (==) or not equals (!=).<p><b>Description</b><br/>Strings should always be compared using one of the comparison methods defined for strings. This audit rule looks for comparisons using either the equals (==) or not equals (!=) operators.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;String currentName, proposedName;<p>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;if (proposedName != currentName) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unhashableClassInHashedCollection">Unhashable class in hashed collection</a></h4><p>
<b>Summary</b><br/>In order to be stored in a hashed collection, a class must override both the <code>equals()</code> method, and the <code>hashCode()</code>, or else it must not override either.<p><b>Description</b><br/>This audit rule finds places where a type that only overrides one of <code>equals()</code> or <code>hashCode()</code> is used in a hashed collection.<h4><a name="com.instantiations.assist.eclipse.audit.unnecessaryCast">Unnecessary Type Cast</a></h4><p>
<b>Summary</b><br/>Unnecessary type casts should be removed.<p><b>Description</b><br/>This audit rule checks for places where a value is being cast to another type and the type cast is not necessary. This includes the following cases:<br>- casting from one type to the same type,<br>- casting from one type to a supertype of that type,<br>- casting to a more specific type when the result will be assigned to a variable of the same type, or<br>- casting immediately prior to using the instanceof operator to test the type.<p><b>Example</b><br/>The following cast would be flagged because the type of the literal is already int:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int i = (int) 0;</code><p>The following cast would be flagged because the variable list can be assigned to the variable collection without the cast:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;List list = new ArrayList();<br>&nbsp;&nbsp;&nbsp;&nbsp;Collection collection = (ArrayList) list;</code><h4><a name="com.instantiations.assist.eclipse.audit.useDeepArraysMethods">Use deep Arrays methods when necessary</a></h4><p>
<b>Summary</b><br/>Use deep <code>Arrays</code> methods when necessary.<p><b>Description</b><br/>The <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code>methods in the Arrays class are shallow methods. That is, if you pass in an array of arrays, the elements in each sub-array will not be considered during the operation. Instead use the <code>deepToString()</code>, <code>deepEquals()</code>, and <code>hashCode()</code><p><b>Example</b><br/>The following would be flagged as a violation:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;Arrays.toString(new int[][] {{1, 2, 3}, {4, 5, 6}});</code><h4><a name="com.instantiations.assist.eclipse.audit.useNoSuchElementException">Use NoSuchElementException in next()</a></h4><p>
<b>Summary</b><br/>An <code>Iterator</code>'s <code>next()</code> method should always be able to throw NoSuchElementExceptions in case a client ignores a false return from <code>hasNext()</code>.<p><b>Description</b><br/>This rule looks for <code>Iterator</code>s whose <code>next()</code> method will never throw a NoSuchElementException.<p><b>Example</b><br/>The following would be flagged as an error: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class FooIterator implements Iterator {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Object next(){};<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.wrongIntegerTypeSuffix">Wrong Integer Type Suffix</a></h4><p>
<b>Summary</b><br/>Long literals should use 'L' for a suffix.<p><b>Description</b><br/>This audit rule looks for long-valued literals whose suffix is a lower-case 'l'. Although the language specification allows this, it is too easily confused with the number one (1), and hence should not be used.<p><b>Example</b><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public static final long ONE = 1l;</code></body>
</html>
