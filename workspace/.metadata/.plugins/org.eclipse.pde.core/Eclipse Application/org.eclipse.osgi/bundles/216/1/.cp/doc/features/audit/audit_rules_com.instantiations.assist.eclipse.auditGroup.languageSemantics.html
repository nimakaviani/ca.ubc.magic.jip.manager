<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Language Semantics</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Language Semantics</font></b></h1>
<b>Description</b><br/>This group contains audit rules that look for language semantic opportunities to make the code more secure.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.analysis.appletFieldSecurity">Applet Field Security</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.avoidInnerClasses">Avoid Inner Classes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.avoidUnsafeArrayDeclaration">Avoid Unsafe Array Declaration</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.disallowReturnMutable">Don't Return Mutable Types</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.gettersShouldBeFinal">Getter and Setter Methods Should Be Final</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.instanceFieldSecurity">Instance Field Security</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.methodCouldBeFinal">Method Could Be Final</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.methodShouldBePrivate">Method Should Be Private</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.mutabilityOfArrays">Mutability Of Arrays</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.mutableConstantField">Mutable Constant Field</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.staticFieldSecurity">Static Field Security</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unknownCast">Unknown Cast</a></li>
      <li><a href="#com.instantiations.assist.eclipse.audit.unusedAssignment">Unused Assignment</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.analysis.appletFieldSecurity">Applet Field Security</a></h4><p>
<b>Summary</b><br/>Enforces Applet fields to be non-private, final and non-static<p><b>Description</b><br/>This audit rule violates all field declarations in Applets that are not private, final and static.<p><b>Security Implications</b><br/>Fields that have all of these characteristics reduce the risk of malicious users from manipulating or gaining internal access to the Applet.<p><b>Example</b><br/>The following integer would be flagged as it is public:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final int x = 0;</code><p><img src="../../images/auditrules/audit_applet_field_security.gif" width="124" height="42"></p><h4><a name="com.instantiations.assist.eclipse.analysis.avoidInnerClasses">Avoid Inner Classes</a></h4><p>
<b>Summary</b><br/>Avoid using inner classes.<p><b>Description</b><br/>Inner classes are flagged and considered a security hazard by this audit rule.<p><b>Security Implications</b><br/>Inner classes are converted into bytecode just like parent classes. Don't depend on an inner class to keep adversaries from private fields. Remember, an inner class has bytecode separate from parent class, but still has access to private fields in the parent class.<p><b>Example</b><br/>The following inner class declaration and the anonymous class declaration would both be flagged as violations:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class OuterClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class InnerClass{}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void foo() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runnable runnable = new Runnable() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run(){/*do nothing*/}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_avoid_inner_classes.gif" width="152" height="42"></p><h4><a name="com.instantiations.assist.eclipse.audit.avoidUnsafeArrayDeclaration">Avoid Unsafe Array Declaration</a></h4><p>
<b>Summary</b><br/>Refrain from declaring an array public, static and final.<p><b>Description</b><br/>This audit rule flags an array declared public, static and final. Arrays are mutable objects, the final constraint requires that the array object itself be assigned only once, but makes no guarantees about the values of the array elements. Since the array is declared public, a malicious program can change the values stored in the array.<p><b>Security Implications</b><br/>Such arrays are many times assumed to be secure and thus used by the application as a secure field. Malicious users can seek out such fields to exploit.<p><b>Example</b><br/>The following Java Applet code would be flagged as a violation because it declares an array public, static and final:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final class UrlTool extends Applet {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static final URL[] urls;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.disallowReturnMutable">Don't Return Mutable Types</a></h4><p>
<b>Summary</b><br/>Don't return mutable types from methods.<p><b>Description</b><br/>Checks that returned types are either default immutable types like java.lang.Integer or are declared immutable in the audit rule preferences.<p><b>Security Implications</b><br/>Methods that return sensitive data that is passed in a mutable form can potentially allow malicious users access to change the data.<p><b>Example</b><br/>The following method declaration would be flagged (assuming "MutableType" is not declared as immutable in the audit rule preferences):<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public MutableType getData() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MutableType();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p><img src="../../images/auditrules/audit_mutable_types.gif" width="134" height="23" align="top">&nbsp;&nbsp;<img src="../../images/auditrules/audit_immutable_types_dialogs.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.gettersShouldBeFinal">Getter and Setter Methods Should Be Final</a></h4><p>
<b>Summary</b><br/>Getter and setter methods should be declared final.<p><b>Description</b><br/>This rule looks for getter and setter methods that are not declared final.<p><b>Security Implications</b><br/>An attacker can modify the behavior of the class by overriding the getter or the setter. This can lead to unexpected and insecure behavior.<p><b>Example</b><br/>The following code would be flagged as a violation because its getter method is not declared final:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Person {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getName() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.instanceFieldSecurity">Instance Field Security</a></h4><p>
<b>Summary</b><br/>Refrain from using non-final public instance fields.<p><b>Description</b><br/>To the extent possible, refrain from using non-final public instance fields. Instead, let the interface to your instance field be through accessor methods. In this way it is possible to add centralized security checks, if required.<p><b>Security Implications</b><br/>Public, non-final fields are accessible and changeable from anywhere within the application making them potential targets of malicious users.<p><b>Example</b><br/>The following field declaration would be flagged as a violation because it is both public and non-final:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public int width;</code><p><img src="../../images/auditrules/audit_instance_field_security.gif" width="308" height="46"></p><h4><a name="com.instantiations.assist.eclipse.audit.methodCouldBeFinal">Method Could Be Final</a></h4><p>
<b>Summary</b><br/>Methods that are not supposed to be overridden should be declared <code>final</code>.<p><b>Description</b><br/>This audit rule looks for non-final, non-abstract method declarations that are declared in a non-final class and are not overridden in subclasses. Such methods should be declared <code>final</code> so that subclasses cannot maliciously redefine the behavior of the method.<p><b>Security Implications</b><br/>A malicious user can redefine the behavior of the method so that it affects the whole class in an unexpected or insecure way.<p><b>Example</b><br/><code>checkSecurity()</code> would be flagged as a violation because it is declared in a non-final class, is not abstract, and is not overridden in subclasses:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class SecureDataAccess {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected void checkSecurity() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.methodShouldBePrivate">Method Should Be Private</a></h4><p>
<b>Summary</b><br/>Method should be private if it is not member of an interface and it doesn't override method of superclass and isn't overriden by subtype. <p><b>Description</b><br/>This audit rule looks for non-private method declarations in subclasses of a specified class that are declared in a class and but are neither overridden in subclasses nor are overrides of methods of a superclass.<p><b>Security Implications</b><br/>In weakly protected environments (like applets) a malicious developer can create code that can use non-private methods and thus access data that otherwise should not be accessible.<p><b>Example</b><br/>If MyClass is added to the list of weakly protected classes, the following method declaration whould be marked as violation because this method is non-private:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class MyClass {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void func() {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.mutabilityOfArrays">Mutability Of Arrays</a></h4><p>
<b>Summary</b><br/>Do not return internal arrays from non-private methods.<p><b>Description</b><br/>This audit rule flags unsafe set or get of an internal array field, this includes flagging: 1) internal array returns from a non-private method and 2) setting an internal array with parameter given through a non-private method.<p><b>Security Implications</b><br/>With arrays, it is safer to make a copy before the set or return. This way, the internal data cannot be manipulated outside of the class.<p><b>Example</b><br/>Given the following field declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;int[] integerArray = ...;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public int[] getIntegerArray() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return integerArray;<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.mutableConstantField">Mutable Constant Field</a></h4><p>
<b>Summary</b><br/>Disallows public static final mutable type fields.<p><b>Description</b><br/>Checks that public static final fields are either default immutable types like java.lang.Integer or are user-specified immutable types, declared through the audit rule preferences.<p><b>Security Implications</b><br/>Public static final mutable fields are accessible and changeable from all points in the application and thus are targets by malicious users.<p><b>Example</b><br/>The following would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public static final MutableType mutableType;</code><p><img src="../../images/auditrules/audit_mutable_types.gif" width="134" height="23" align="top">&nbsp;&nbsp;<img src="../../images/auditrules/audit_immutable_types_dialogs.gif"></p><h4><a name="com.instantiations.assist.eclipse.audit.staticFieldSecurity">Static Field Security</a></h4><p>
<b>Summary</b><br/>Refrain from using non-final public static fields.<p><b>Description</b><br/>To the extent possible, refrain from using non-final public static fields because there is no way to check whether the code that changes such fields has appropriate permissions.<p><b>Security Implications</b><br/>Public, non-final static fields are accessible and changeable from anywhere within the application making them potential targets of malicious users.<p><b>Example</b><br/>The following declaration would be flagged as a violation because it is both public and non-final:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public static int minutesPerHour = 60;</code><p><img src="../../images/auditrules/audit_static_field_security.gif" width="297" height="43"></p><h4><a name="com.instantiations.assist.eclipse.audit.unknownCast">Unknown Cast</a></h4><p>
<b>Summary</b><br/>When an object is checked for being an instance of one class and then cast to another class that is neither inherited from the checked class nor its ancestor this usually results in a ClassCastException.<p><b>Description</b><br/>This audit rule violates class casts that are preceded with a check of the same instance for being intanceof of the incomparable class.<p><b>Security Implications</b><br/>Such a cast is usually an error which results in a <code>ClassCastException</code>. This may result in an unexpected behavior of an application that could possibly compromise its security.<p><b>Example</b><br/>The following code would be flagged as a violation because it performs a check for one class and then casts the instance on an incomparable class:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;if (s instanceof String) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer db = (StringBuffer) s;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.audit.unusedAssignment">Unused Assignment</a></h4><p>
<b>Summary</b><br/>Local variable or parameter is assigned a value that is never used.<p><b>Description</b><br/>This rule violates cases when local variable or parameter is assigned a value that is either reassigned or simply not used till the end of the scope.<p><b>Security Implications</b><br/>Unused result of an assignment usually indicates inconsistency in the code, possible errors or poorly mantained code, which may result in a security threat.<p><b>Example</b><br/>The following method reassignes a parameter without using its initial value. This is probably a misprint or an outdated code and should be removed: <p><code>&nbsp;&nbsp;&nbsp;&nbsp;public void testReassigned(int i) {<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 10;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
