<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="CodePro AnalytiX">
<title>Audit - Rules - Hibernate</title>
<style type="text/css">
  body {font: 70% verdana,arial,helvetica; color: #000000}
  p {margin: 0.5em 2em 1em; line-height: 1.5em}
  h1 {margin: 0px 0px 5px; font: 175% verdana,arial,helvetica}
  h2 {margin: 0px 0px 5px; font: bold 175% verdana,arial,helvetica}
  h3 {margin: 0px 0px 5px; font: 125% verdana,arial,helvetica}
  h4 {margin-top: 1em; margin-bottom: 0.5em; font: bold 125% verdana,arial,helvetica}
  table tr th {font-size: 75%}
  table tr td {font-size: 75%} 
</style>
</head>

<body>
<table>
  <tr>
    <td>
      <h1><b><font face="Verdana" color="#CC0000">Audit - Rules - Hibernate</font></b></h1>
<b>Description</b><br/>This group contains audit rules that check for problems related to the use of Hibernate, an object/relational persistence and query service.</p>
</td>
  </tr><tr>
    <td>
      <b>Rules:</b>
<ul>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.alwaysUseIdentifierProperties">Always Use Identifier Names</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.avoidUsingFieldAccessStrategy">Avoid Using "Field Access" Strategy</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.classesShouldBeTheirOwnProxy">Classes Should be Their Own Proxy</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.closeSessionsWhereOpened">Close Sessions Where Opened</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.declareAccessors">Declare Accessors for Persistent Fields</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.declareIdentifierProperties">Declare Identifier Properties</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.declarePrivateSetter">Declare Private Identifier Setter</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.declareTypeForDateProperty">Declare Type for java.util.Date Property</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.deployMappings">Deploy Mappings With Mapped Classes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.implementZeroArgConstructor">Implement a Zero-Argument Constructor</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.invalidPropertyTypeMapping">Invalid Property Type Mapping</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.neverUseDatabaseIdentifier">Never Use the Identifier in equals() or hashCode()</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.oneClassPerMappingFile">One Class per Mapping File</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.referencedClassNotDefined">Referenced Class Not Defined</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.rollbackTransaction">Rollback Transaction on Exception</a></li>
      <li><a href="#com.instantiations.assist.eclipse.analysis.sqlInjection">SQL Injection</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.useNullableTypes">Use "Nullable" Type for Identifier Properties</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.useInterfacesForCollectionAttributes">Use Interfaces for Collection Attributes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.useOnlyNonFinalClasses">Use Only Non-Final Persistent Classes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.useOnlyStaticInnerClasses">Use Only Static Inner Classes</a></li>
      <li><a href="#com.instantiations.assist.eclipse.hibernate.useSessionPerRequestPattern">Use Session-per-request Pattern</a></li>
      </ul>
    </td>
  </tr>
</table>
<hr size="2">
<h4>Details</h4>
<h4><a name="com.instantiations.assist.eclipse.hibernate.alwaysUseIdentifierProperties">Always Use Identifier Names</a></h4><p>
<b>Summary</b><br/>You should always specify a name attribute for identifiers in Hibernate.<p><b>Description</b><br/>This audit rule looks for identifier declarations that do not include a name attribute. If you do not specify a name attribute you allow Hibernate to manage database identity internally. For example, consider the following mapping declaration:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;id column="CATEGORY_ID"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator class="native"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;</code><p>Hibernate will now manage the identifier values internally. But this technique has a serious drawback: you can no longer use Hibernate to manipulate detached objects effectively. So, you should always specify a name attribute in Hibernate. (If you don't like them being visible to the rest of your application, make the accessor methods private.)<p><b>Example</b><br/>The following identifier declaration would be flagged because it does not include a name attribute:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;id column="CATEGORY_ID"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator class="native"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;</code><p>you should use something like following:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;id name="category" column="CATEGORY_ID"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator class="native"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.avoidUsingFieldAccessStrategy">Avoid Using "Field Access" Strategy</a></h4><p>
<b>Summary</b><br/>Access to properties via accessor methods is considered best practice by the Hibernate community.<p><b>Description</b><br/>The access attribute allows you to specify how Hibernate should access property values of the POJO. The default strategy, "property", uses the property accessors (get/set method pair). The "field" strategy uses reflection to access the instance variable directly. Access to properties via accessor methods is considered best practice by the Hibernate community. It provides an extra level of abstraction between the Java domain model and the data model, beyond what is already provided by Hibernate. Properties are more flexible; for example, property definitions may be overridden by persistent subclasses.<p>This rule will only create a violation if both accessor methods are defined for the field. You can use the Declare Accessors for Persistent Fields rule to ensure that accessor methods exist.<p><b>Example</b><br/>The value of the "access" attribute would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="name" column="NAME" access="field"&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.classesShouldBeTheirOwnProxy">Classes Should be Their Own Proxy</a></h4><p>
<b>Summary</b><br/>Every persistent class should be its own proxy.<p><b>Description</b><br/>This audit rule looks for declarations of persistent classes in which a proxy is specified that is different from the class itself. The Hibernate framework recommends that every persistent class should be its own proxy.<p><b>Example</b><br/>The following tag would be flagged because the proxy class is not the same as the class being described<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="eg.Order" proxy="eg.IOrder"&gt;</code><p>It should be replaced by the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="eg.Order" proxy="eg.Order"&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.closeSessionsWhereOpened">Close Sessions Where Opened</a></h4><p>
<b>Summary</b><br/>Close sessions in the method where they are opened.<p><b>Description</b><br/>This audit rule looks for methods in which a session is opened but not closed. The method Session.close() should be invoked in the same method as the method SessionFactory.openSession().<p><b>Example</b><br/>The following method would be flagged because the opened session isn't closed.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void createMessage(String text, Date date) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session = sessionFactory.openSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message message = new Message();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.setText(text);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.setDate(date);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.save(message);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getTransaction().commit();<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>To close the session, the method session.close() should be invoked in a finally block, as shown below<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void createMessage(String text, Date date) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session = sessionFactory.openSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message message = new Message();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.setText(text);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.setDate(date);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.save(message);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.declareAccessors">Declare Accessors for Persistent Fields</a></h4><p>
<b>Summary</b><br/>Declare accessor methods for all persistent fields of persistent class.<p><b>Description</b><br/>This audit rule looks for fields in persistent classes for which either the getter or setter method is missing. Many other ORM tools directly persist instance variables, but Hibernate decouples this implementation detail from the persistence mechanism. Hibernate persists JavaBeans style properties, and recognizes method names of the form getFoo, isFoo and setFoo. Properties need not be declared public - Hibernate can persist a property with a default, protected or private get/set pair.<p><b>Example</b><br/>The fields "text" and "nextMessage" would be flagged because they do not have getter or setter methods.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Long id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message() {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Long getId() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void setId(Long id) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getText() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.declareIdentifierProperties">Declare Identifier Properties</a></h4><p>
<b>Summary</b><br/>Declare identifier properties on persistent classes.<p><b>Description</b><br/>This audit rule looks for persistent classes that do not have an identifier property declared for them. Although Hibernate makes identifier properties optional, some functionality is available only to classes which declare an identifier property, including<p>1. Transitive reattachment for detached objects (cascade update or cascade merge)<br>2. Session.saveOrUpdate()<br>3. Session.merge()<p><b>Example</b><br/>The following class would be flagged because there is no identifier field declared for it.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message() {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public String getText() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setText(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message getNextMessage() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nextMessage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setNextMessage(Message nextMessage) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextMessage = nextMessage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.declarePrivateSetter">Declare Private Identifier Setter</a></h4><p>
<b>Summary</b><br/>The setter method for an identifier property should be private.<p><b>Description</b><br/>This audit rule looks for non-private methods used to set the value of an identifier field. The identifier field should only be assigned a value by Hibernate when the object is saved. By making the method private you ensure that other code cannot change the object's identity.<p><b>Example</b><br/>The "setId" method would be flagged because it should be private.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Long id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message() {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Long getId() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void setId(Long id) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;his.id = id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.declareTypeForDateProperty">Declare Type for java.util.Date Property</a></h4><p>
<b>Summary</b><br/>Declare type for java.util.Date property in configuration file.<p><b>Description</b><br/>This audit rule looks for declarations of properties in the configuration files whose corresponding field has the type java.util.Date, but for which the property file does not contain a "type" attribute. Without a "type" attribute, Hibernate can't know if the property should map to an SQL date, a timestamp, or a time column.<p><b>Example</b><br/>Given a class defined like the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Long id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Date date;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message () {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Long getId() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void setId(Long id) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>and a corresponding configuration file containing the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;hibernate-mapping&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="messages.Message" table="MESSAGES"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;id name="id" column="MESSAGE_ID"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator class="native"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="date" column="MESSAGE_DATE"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="text"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/hibernate-mapping&gt;</code><p>The property "date" would be flagged because it does not include the attribute "type". It should be replaced by something like the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="date" type="timestamp" column="MESSAGE_DATE"/&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.deployMappings">Deploy Mappings With Mapped Classes</a></h4><p>
<b>Summary</b><br/>Deploy the mapping files along with the classes they map.<p><b>Description</b><br/>This audit rule looks for mapping files that are not in the same directory as the class being mapped. Having the mapping documents in a different directory makes it harder to keep the information in the file up to date and makes it harder to refactor the code when necessary. For example, the class com.eg.Foo should be mapped in the file com/eg/Foo.hbm.xml. This makes particularly good sense in a team environment.<p><b>Example</b><br/>Given the following entry in the "hibernate.cfg.xml" file<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;mapping resource="helloMessage.hbm.xml"/&gt;</code><p>The file "helloMessage.hbm.xml", containing the mapping entry below, would be flagged because it is not in the same directory as the mapped resource.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;hibernate-mapping&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="hello.Message"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table="MESSAGES"&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/hibernate-mapping&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.implementZeroArgConstructor">Implement a Zero-Argument Constructor</a></h4><p>
<b>Summary</b><br/>Implement a zero-argument constructor for persistent classes.<p><b>Description</b><br/>This audit rule looks for persistent classes that do not explicitly implement a zero-argument constructor. The constructor does not need to be public, but it needs to exist so that Hibernate can instantiate the class using Constructor.newInstance().<p><b>Example</b><br/>The following class would be flagged because it has no explicitly defined constructor.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Long id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Long getId() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void setId(Long id) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.invalidPropertyTypeMapping">Invalid Property Type Mapping</a></h4><p>
<b>Summary</b><br/>Map a Hibernate property type only to the corresponding Java type.<p><b>Description</b><br/>This audit rule looks for properties whose type is a standard type and checks to make sure that the actual type of the corresponding field is appropriate for the property's type. Non-standard types are ignored.<p>The following is a table of standard property types and the appropriate types to which they can be mapped.<p>Property Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java Type<br>integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int, java.lang.Integer<br>long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long, java.lang.Long<br>short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short, java.lang.Short<br>float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float, java.lang.Float<br>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double, java.lang.Double<br>character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char, java.lang.Character<br>byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte, java.lang.Byte<br>boolean, yes_no, true_false&nbsp;&nbsp;&nbsp;&nbsp;boolean, java.lang.Boolean<br>string, text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.lang.String<br>date, time, timestamp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.Date<br>calendar, calendar_date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.Calendar<br>big_decimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.math.BigDecimal<br>locale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.Locale<br>timezone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.TimeZone<br>currency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.util.Currency<br>class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.lang.Class<br>binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte arrays<br>clob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.Clob<br>blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.Blob<p><b>Example</b><br/>Given a class Message containing the following field declaration<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private String text;</code><p>The folowing property in the file Message.hbm.xml would be flagged, because the property type "byte" doesn't correspond with Java type "String".<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="text" column="MESSAGE_TEXT" type="byte"/&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.neverUseDatabaseIdentifier">Never Use the Identifier in equals() or hashCode()</a></h4><p>
<b>Summary</b><br/>Never ever use the database identifier in the equals() and hashCode() methods, because a transient object doesn't have an identifier value.<p><b>Description</b><br/>This audit rule looks for uses of the identifier field in the implementation of either the equals() or hashCode() methods. A transient object doesn't have an identifier value because Hibernate will only assign a value when the object is saved. To implement equals() and hashCode(), use a unique business key, that is, compare a unique combination of class properties.<p><b>Example</b><br/>The equals() method would be flagged because it uses the identifier property.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Long id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public boolean equals(Object obj) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (obj instanceof Message) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message message = (Message)obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (message.getId() == getId()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.oneClassPerMappingFile">One Class per Mapping File</a></h4><p>
<b>Summary</b><br/>Use one mapping file per persistent class.<p><b>Description</b><br/>This audit rule looks for mapping files declaring mappings for multiple classes. Although it's possible to declare mappings for multiple classes in one mapping file by using multiple &lt;class&gt; elements, the recommended practice (and the practice expected by some Hibernate tools) is to use one mapping file per persistent class.<p><b>Example</b><br/>Given a mapping file (*.hbm.xml) containing the following, the second "class" entry would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;hibernate-mapping&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/hibernate-mapping&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.referencedClassNotDefined">Referenced Class Not Defined</a></h4><p>
<b>Summary</b><br/>Classes referenced in the configuration file (*.hbm.xml) should be declared.<p><b>Description</b><br/>This audit rule checks for references within a Hibernate configuration file to classes that are not declared in the associated project. Hibernate will not work correctly if undeclared classes are referenced. Either the references should be removed or the classes should be declared.<p><b>Example</b><br/>In the following entry (from a *.hbm.xml file), the value of the "name" attribute would be flagged<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="class.not.exists" ... /&gt;</code><h4><a name="com.instantiations.assist.eclipse.hibernate.rollbackTransaction">Rollback Transaction on Exception</a></h4><p>
<b>Summary</b><br/>Rollback transactions if an exception occurs.<p><b>Description</b><br/>If the session throws an exception (including any SQLException), you should immediately rollback the transaction, call Session.close() and discard the session instance because certain methods of Session will not leave the session in a consistent state. This audit rule looks for places where the transaction will not be rolled back correctly.<p><b>Example</b><br/>The following method would be flagged because it doesn't rollback the transaction if an exception occurs.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void transactionExample(...) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session = factory.openSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transaction tx = session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do some work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.commit();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>It should be replaced by something like the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void transactionExample(...) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session = factory.openSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transaction tx = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx = session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do some work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.commit();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tx != null) tx.rollback();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.analysis.sqlInjection">SQL Injection</a></h4><p>
<b>Summary</b><br/>SQL queries might be receiving data from the user or other unsafe sources.<p><b>Description</b><br/>SQL Injection occurs when the user is able to enter data directly into SQL queries.<p>To detect violations, this audit rule searches the code for SQL queries such as <code>java.sql.Statement.execute(..)</code> and traces where the query data could have come from. In cases where the source of the query is user input, such as data from a servlet request, <code>javax.servlet.ServletRequest.getParameter(java.lang.String)</code>, or from a SWT Text widget, <code>org.eclipse.swt.widgets.Text.getText()</code>, a violation is created.<p>These two sets of methods, the locations where tainted user data can come from and the methods used to query the database, are editable by the user.If methods are missing that are in a common package (such as <code>java.lang.*</code>), please let CodePro support know.<p>Also note, the SQL query methods for Hibernate and Persistence frameworks have been added.<p><b>Security Implications</b><br/>Successful SQL Injection attacks can potentially drop tables, update the database in a malicious manner and even gain administrator access.<p><b>Example</b><br/>The invocation of the method <code>executeQuery(..)</code> would be flagged as a violation since it uses the first name information passed from a servlet request:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;ServletRequest servletRequest;<br>&nbsp;&nbsp;&nbsp;&nbsp;Connection connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;Statement statement;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;servletRequest = ...;<br>&nbsp;&nbsp;&nbsp;&nbsp;connection = DriverManager.getConnection("www.example.com", "myUserName", "myPassword");<br>&nbsp;&nbsp;&nbsp;&nbsp;statement = connection.createStatement();<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;String firstName = req.getParameter("firstName");<br>&nbsp;&nbsp;&nbsp;&nbsp;String query = "SELECT * FROM user_data WHERE firstName = '" + firstName + "'";<br>&nbsp;&nbsp;&nbsp;&nbsp;statement.executeQuery(query);<br></code><p><img src="../../images/auditrules/audit_sql_injection.gif"></p><h4><a name="com.instantiations.assist.eclipse.hibernate.useNullableTypes">Use "Nullable" Type for Identifier Properties</a></h4><p>
<b>Summary</b><br/>Use a "nullable" type for identifier properties of persistent classes.<p><b>Description</b><br/>Identifier properties of persistent classes should be 'synthetic' (generated, with no business meaning) and of a non-primitive type. This audit rule looks for identifier properties with a primitive type. For maximum flexibility, use java.lang.Long or java.lang.String.<p><b>Example</b><br/>The following class would be flagged because it has a primitive-valued identifier field.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Message nextMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message() {}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Message(String text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.text = text;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int getId() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private void setId(int id) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.useInterfacesForCollectionAttributes">Use Interfaces for Collection Attributes</a></h4><p>
<b>Summary</b><br/>Hibernate requires that collection-valued properties be typed to an interface such as java.util.Set or java.util.List and not to an actual implementation such as java.util.HashSet (this is a good practice).<p><b>Description</b><br/>Hibernate requires interfaces for collection-typed attributes. You must use java.util.Set rather than HashSet, for example. At runtime, Hibernate wraps the HashSet instance with an instance of one of Hibernate's own classes. (This special class isn't visible to the application code). It is good practice to program to collection interfaces, rather than concrete implementations.<p><b>Example</b><br/>childCategories would be flagged:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public class Category {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private Category parentCategory;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private HashSet childCategories = new HashSet();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Category() { }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.useOnlyNonFinalClasses">Use Only Non-Final Persistent Classes</a></h4><p>
<b>Summary</b><br/>Use only non-final persistent classes.<p><b>Description</b><br/>This audit rule looks for persistent classes for which a proxy cannot be created. The use of proxies, a central feature of Hibernate, depends on the persistent class being either non-final, or the implementation of an interface that declares all of the public methods.<p>You can persist final classes that do not implement an interface with Hibernate, but you won't be able to use proxies for lazy association fetching - which will limit your options for performance tuning.<p><b>Example</b><br/>The following persistent class would be flagged because it is final.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final class Message {<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.useOnlyStaticInnerClasses">Use Only Static Inner Classes</a></h4><p>
<b>Summary</b><br/>Use only static inner persistent classes.<p><b>Description</b><br/>This audit rule looks for inner classes that are declared to be persistent and checks to make sure that they are static. Hibernate cannot persist non-static inner classes.<p><b>Example</b><br/>If the mapping file OuterClass$NestedClass.hbm.xml contains<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&lt;class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="OuterClass$NestedClass" ... &gt;</code><p>then the persistent class NestedClass would be flagged because it non-static:<p><code>&nbsp;&nbsp;&nbsp;&nbsp;public final class OuterClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class NestedClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><h4><a name="com.instantiations.assist.eclipse.hibernate.useSessionPerRequestPattern">Use Session-per-request Pattern</a></h4><p>
<b>Summary</b><br/>Don't use the session-per-operation antipattern.<p><b>Description</b><br/>This audit rule looks for uses of the session-per-operation antipattern in which a session is opened and closed for every simple database call in a single method, which in turn required beginning and committing a database transactions for each database call as well.<p>Database calls in an application are made using a planned sequence, they are grouped into atomic units of work. In the session-per-request model, a request from the client is send to the server (where the Hibernate persistence layer runs), a new Hibernate Session is opened, and all database operations are executed in this unit of work. Once the work has been completed (and the response for the client has been prepared), the session is flushed and closed. You would also use a single database transaction to serve the clients request, starting and committing it when you open and close the Session.<p>This rule assumes that each method that creates a session is performing a single unit of work. If there are methods performing multiple units of work, they should be refactored into separate methods.<p><b>Example</b><br/>The following method would be flagged because it use the session-per-operation antipattern.<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void addPersonToEvent(Long personId, Long eventId) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session1 = sessionFactory.getCurrentSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person aPerson = (Person) session.load(Person.class, personId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getTransaction().commit();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session2 = sessionFactory.getCurrentSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event anEvent = (Event) session.load(Event.class, eventId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getTransaction().commit();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session3 = sessionFactory.getCurrentSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aPerson.getEvents().add(anEvent);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getTransaction().commit();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code><p>It should be replaced by something like the following<p><code>&nbsp;&nbsp;&nbsp;&nbsp;private void addPersonToEvent(Long personId, Long eventId) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Session session = sessionFactory.getCurrentSession();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.beginTransaction();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person aPerson = (Person) session.load(Person.class, personId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event anEvent = (Event) session.load(Event.class, eventId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aPerson.getEvents().add(anEvent);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.getTransaction().commit();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></body>
</html>
